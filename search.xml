<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Leetcode-1441-用栈操作构建数组</title>
    <url>/2022/10/17/Leetcode-1441-%E7%94%A8%E6%A0%88%E6%93%8D%E4%BD%9C%E6%9E%84%E5%BB%BA%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个数组<code>target</code>和一个整数<code>n</code>。每次迭代，需要从 <code>list = &#123; 1 , 2 , 3 ..., n &#125;</code>中依次读取一个数字。</p>
<span id="more"></span>

<p>请使用下述操作来构建目标数组<code>target</code>：</p>
<ul>
<li><code>&quot;Push&quot;</code>：从<code>list</code>中读取一个新元素， 并将其推入数组中。</li>
<li><code>&quot;Pop&quot;</code>：删除数组中的最后一个元素。</li>
<li>如果目标数组构建完成，就停止读取更多元素。</li>
</ul>
<p>题目数据保证目标数组严格递增，并且只包含<code>1</code>到<code>n</code>之间的数字。</p>
<p>请返回构建目标数组所用的操作序列。如果存在多个可行方案，返回任一即可。</p>
<h4 id="示例-1："><a href="#示例-1：" class="headerlink" title="示例 1："></a>示例 1：</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">输入：target = [1,3], n = 3</span><br><span class="line">输出：[<span class="string">&quot;Push&quot;</span>,<span class="string">&quot;Push&quot;</span>,<span class="string">&quot;Pop&quot;</span>,<span class="string">&quot;Push&quot;</span>]</span><br><span class="line">解释： </span><br><span class="line">读取 1 并自动推入数组 -&gt; [1]</span><br><span class="line">读取 2 并自动推入数组，然后删除它 -&gt; [1]</span><br><span class="line">读取 3 并自动推入数组 -&gt; [1,3]</span><br></pre></td></tr></table></figure>

<h4 id="示例-2："><a href="#示例-2：" class="headerlink" title="示例 2："></a>示例 2：</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">输入：target = [1,2,3], n = 3</span><br><span class="line">输出：[<span class="string">&quot;Push&quot;</span>,<span class="string">&quot;Push&quot;</span>,<span class="string">&quot;Push&quot;</span>]</span><br></pre></td></tr></table></figure>

<h4 id="示例-3："><a href="#示例-3：" class="headerlink" title="示例 3："></a>示例 3：</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">输入：target = [1,2], n = 4</span><br><span class="line">输出：[<span class="string">&quot;Push&quot;</span>,<span class="string">&quot;Push&quot;</span>]</span><br><span class="line">解释：只需要读取前 2 个数字就可以停止。</span><br></pre></td></tr></table></figure>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>题目中给出的数组是严格递增的，因此我们可以遍历<code>target</code>，同时维护一个<code>temp</code>，从<code>1</code>开始</p>
<ul>
<li>若<code>target</code>中的数不等于<code>temp</code>时<ul>
<li>添加[“Push”, “Pop”]</li>
</ul>
</li>
<li>若<code>target</code>中的数不等于<code>temp</code>时<ul>
<li>添加[“Push”]</li>
</ul>
</li>
</ul>
<p>遍历完成即数组构建完成</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> IList&lt;<span class="built_in">string</span>&gt; <span class="title">BuildArray</span>(<span class="params"><span class="built_in">int</span>[] target, <span class="built_in">int</span> n</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> temp = <span class="number">1</span>;</span><br><span class="line">    List&lt;<span class="built_in">string</span>&gt; result = <span class="keyword">new</span> List&lt;<span class="built_in">string</span>&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; target.Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (target[i] != temp) </span><br><span class="line">        &#123;</span><br><span class="line">            result.Add(<span class="string">&quot;Push&quot;</span>);</span><br><span class="line">            result.Add(<span class="string">&quot;Pop&quot;</span>);</span><br><span class="line">            temp++;</span><br><span class="line">        &#125;</span><br><span class="line">        result.Add(<span class="string">&quot;Push&quot;</span>);</span><br><span class="line">        temp++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-1611-使整数变为0的最少操作次数</title>
    <url>/2022/10/13/Leetcode-1611-%E4%BD%BF%E6%95%B4%E6%95%B0%E5%8F%98%E4%B8%BA0%E7%9A%84%E6%9C%80%E5%B0%91%E6%93%8D%E4%BD%9C%E6%AC%A1%E6%95%B0/</url>
    <content><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个整数<code>n</code>，你需要重复执行多次下述操作将其转换为<code>0</code>：</p>
<ul>
<li>翻转<code>n</code>的二进制表示中最右侧位（第<code>0</code>位）。</li>
<li>如果第<code>(i-1)</code>位为<code>1</code>且从第<code>(i-2)</code>位到第<code>0</code>位都为<code>0</code>，则翻转<code>n</code>的二进制表示中的第<code>i</code>位。</li>
</ul>
<p>返回将 n 转换为 0 的最小操作次数。</p>
<span id="more"></span>

<h4 id="示例-1："><a href="#示例-1：" class="headerlink" title="示例 1："></a>示例 1：</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">输入：n = 3</span><br><span class="line">输出：2</span><br><span class="line">解释：3 的二进制表示为 <span class="string">&quot;11&quot;</span></span><br><span class="line"><span class="string">&quot;11&quot;</span> -&gt; <span class="string">&quot;01&quot;</span> ，执行的是第 2 种操作，因为第 0 位为 1 。</span><br><span class="line"><span class="string">&quot;01&quot;</span> -&gt; <span class="string">&quot;00&quot;</span> ，执行的是第 1 种操作。</span><br></pre></td></tr></table></figure>

<h4 id="示例-2："><a href="#示例-2：" class="headerlink" title="示例 2："></a>示例 2：</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">输入：n = 6</span><br><span class="line">输出：4</span><br><span class="line">解释：6 的二进制表示为 <span class="string">&quot;110&quot;</span>.</span><br><span class="line"><span class="string">&quot;110&quot;</span> -&gt; <span class="string">&quot;010&quot;</span> ，执行的是第 2 种操作，因为第 1 位为 1 ，第 0 到 0 位为 0 。</span><br><span class="line"><span class="string">&quot;010&quot;</span> -&gt; <span class="string">&quot;011&quot;</span> ，执行的是第 1 种操作。</span><br><span class="line"><span class="string">&quot;011&quot;</span> -&gt; <span class="string">&quot;001&quot;</span> ，执行的是第 2 种操作，因为第 0 位为 1 。</span><br><span class="line"><span class="string">&quot;001&quot;</span> -&gt; <span class="string">&quot;000&quot;</span> ，执行的是第 1 种操作。</span><br></pre></td></tr></table></figure>

<ul>
<li>提示<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">0 &lt;= n &lt;= 109</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>首先我们先观察1-7移动需要的步数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">变化     原数据 (n)        需要步数 f(n)</span><br><span class="line">100       4              7</span><br><span class="line">101       5              6</span><br><span class="line">111       7              5  </span><br><span class="line">110       6              4</span><br><span class="line">010       2              3</span><br><span class="line">011       3              2</span><br><span class="line">001       1              1</span><br><span class="line">000       0              0</span><br></pre></td></tr></table></figure>

<p>此处可以观察到数为2^k需要的步数是小于<code>2^（k+1）-1</code>中步数最多的，且其步数为<code>2^（k+1）-1</code>，例如4(2^2)，步数为2^3-1&#x3D;7</p>
<p>且从该数变为0的过程中会经过小于<code>2^（k+1）-1</code>的所有数字，则可将该题转化一下，若要求n,将n转化位2^k+j的形式，则步数为f(2^k)-f(j),例如7，为2^2+3，其步数为f(4)-f(3)&#x3D;7-2&#x3D;5</p>
<p>如何发现其规则：从该数变为0的过程中会经过小于该数的所有数字，则从4变为7的过程，首尾1不动，其实就是反向的从11（二进制）变为00（二进制）的过程，因此用f(4)-f(3)即为步数</p>
<p>只需要将该数转化为的二进制数数组，然后遍历一遍数组即可得到使整数变为0的最少操作次数</p>
<p>举例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">25 -&gt; 11001 -&gt; f(16)-f(9)=f(16)-（f(8)-f(1)）=31-(15-1)=17</span><br><span class="line"></span><br><span class="line">从后向前遍历，开始（i=0）为1，即为2^0-1=1。 temp=1</span><br><span class="line">（i=3）  即为2^4-1=15       temp=15-1=14</span><br><span class="line">（i=4）  即为2^5-1=31       temp=31-14=17</span><br></pre></td></tr></table></figure>

<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">MinimumOneBitOperations</span>(<span class="params"><span class="built_in">int</span> n</span>)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//此处将n转换为二进制数数组，从后向前遍历           </span></span><br><span class="line">    <span class="built_in">char</span>[] charArray = Convert.ToString(n, <span class="number">2</span>).ToCharArray();</span><br><span class="line">    <span class="built_in">int</span> length = charArray.Length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//如果字符为&#x27;1&#x27;,就用(2^(i+1)-1)减去result</span></span><br><span class="line">        <span class="keyword">if</span> (charArray[length - i - <span class="number">1</span>] == <span class="string">&#x27;1&#x27;</span>)               </span><br><span class="line">        &#123;</span><br><span class="line">            result = ((<span class="number">2</span> &lt;&lt; (i))<span class="number">-1</span>)-result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-1953-你可以工作的最大周数</title>
    <url>/2022/10/19/Leetcode-1953-%E4%BD%A0%E5%8F%AF%E4%BB%A5%E5%B7%A5%E4%BD%9C%E7%9A%84%E6%9C%80%E5%A4%A7%E5%91%A8%E6%95%B0/</url>
    <content><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你<code>n</code>个项目，编号从<code>0</code>到<code>n - 1</code>。同时给你一个整数数组<code>milestones</code>，其中每个<code>milestones[i]</code>表示第<code>i</code>个项目中的阶段任务数量。</p>
<span id="more"></span>
<p>你可以按下面两个规则参与项目中的工作：</p>
<p>每周，你将会完成<strong>某一个</strong>项目中的<strong>恰好一个</strong>阶段任务。你每周都<strong>必须</strong>工作。<br>在<strong>连续的</strong>两周中，你<strong>不能</strong>参与并完成同一个项目中的两个阶段任务。<br>一旦所有项目中的全部阶段任务都完成，或者仅剩余一个阶段任务都会导致你违反上面的规则，那么你将<strong>停止工作</strong>。注意，由于这些条件的限制，你可能无法完成所有阶段任务。</p>
<p>返回在不违反上面规则的情况下你<strong>最多</strong>能工作多少周。</p>
<h4 id="示例-1："><a href="#示例-1：" class="headerlink" title="示例 1："></a>示例 1：</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">输入：milestones = [1,2,3]</span><br><span class="line">输出：6</span><br><span class="line">解释：一种可能的情形是：</span><br><span class="line">​​​​- 第 1 周，你参与并完成项目 0 中的一个阶段任务。</span><br><span class="line">- 第 2 周，你参与并完成项目 2 中的一个阶段任务。</span><br><span class="line">- 第 3 周，你参与并完成项目 1 中的一个阶段任务。</span><br><span class="line">- 第 4 周，你参与并完成项目 2 中的一个阶段任务。</span><br><span class="line">- 第 5 周，你参与并完成项目 1 中的一个阶段任务。</span><br><span class="line">- 第 6 周，你参与并完成项目 2 中的一个阶段任务。</span><br><span class="line">总周数是 6 。</span><br></pre></td></tr></table></figure>

<h4 id="示例-2："><a href="#示例-2：" class="headerlink" title="示例 2："></a>示例 2：</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">输入：milestones = [5,2,1]</span><br><span class="line">输出：7</span><br><span class="line">解释：一种可能的情形是：</span><br><span class="line">- 第 1 周，你参与并完成项目 0 中的一个阶段任务。</span><br><span class="line">- 第 2 周，你参与并完成项目 1 中的一个阶段任务。</span><br><span class="line">- 第 3 周，你参与并完成项目 0 中的一个阶段任务。</span><br><span class="line">- 第 4 周，你参与并完成项目 1 中的一个阶段任务。</span><br><span class="line">- 第 5 周，你参与并完成项目 0 中的一个阶段任务。</span><br><span class="line">- 第 6 周，你参与并完成项目 2 中的一个阶段任务。</span><br><span class="line">- 第 7 周，你参与并完成项目 0 中的一个阶段任务。</span><br><span class="line">总周数是 7 。</span><br><span class="line">注意，你不能在第 8 周参与完成项目 0 中的最后一个阶段任务，因为这会违反规则。</span><br><span class="line">因此，项目 0 中会有一个阶段任务维持未完成状态。</span><br></pre></td></tr></table></figure>

<ul>
<li>提示<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">n == milestones.length</span><br><span class="line">1 &lt;= n &lt;= 105</span><br><span class="line">1 &lt;= milestones[i] &lt;= 109</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>本题采用贪心法的思路去处理，我们处理花费时长最多的项目，我们再处理该项目的时候，中间会插入其他项目</p>
<ul>
<li>若此时其他项目的总花费时间小于该项目时间，则最终工作时间为（其他项目时间总和*2）+1</li>
<li>若此时其他项目的总花费时间大于该项目时间，则一定可以穿插完成所有项目，即最终工作时间为所有项目时间总和</li>
</ul>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">long</span> <span class="title">NumberOfWeeks</span>(<span class="params"><span class="built_in">int</span>[] milestones</span>)</span> </span><br><span class="line">&#123;</span><br><span class="line">    Array.Sort(milestones);</span><br><span class="line">    <span class="built_in">long</span> temp = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">int</span> maxNum = milestones[milestones.Length - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; milestones.Length<span class="number">-1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        temp += milestones[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxNum &gt; temp ? (<span class="number">2</span>*temp+<span class="number">1</span>) : maxNum+temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-453-最小操作次数使数组元素相等</title>
    <url>/2022/10/12/Leetcode-453-%E6%9C%80%E5%B0%8F%E6%93%8D%E4%BD%9C%E6%AC%A1%E6%95%B0%E4%BD%BF%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E7%9B%B8%E7%AD%89/</url>
    <content><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个长度为 n 的整数数组，每次操作将会使 n - 1 个元素增加 1 。返回让数组所有元素相等的最小操作次数。</p>
<span id="more"></span>

<h4 id="示例-1："><a href="#示例-1：" class="headerlink" title="示例 1："></a>示例 1：</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,2,3]</span><br><span class="line">输出：3</span><br><span class="line">解释：</span><br><span class="line">只需要3次操作（注意每次操作会增加两个元素的值）：</span><br><span class="line">[1,2,3]  =&gt;  [2,3,3]  =&gt;  [3,4,3]  =&gt;  [4,4,4]</span><br></pre></td></tr></table></figure>

<h4 id="示例-2："><a href="#示例-2：" class="headerlink" title="示例 2："></a>示例 2：</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,1,1]</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure>

<ul>
<li>提示<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">n == nums.length</span><br><span class="line">1 &lt;= nums.length &lt;= 105</span><br><span class="line">-109 &lt;= nums[i] &lt;= 109</span><br><span class="line">答案保证符合 32-bit 整数</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>题目为每次操作将会让 n - 1 个元素增加 1 ，反着理解的话即为每次将 1 个元素减少 1 让数组中元素相等，这样就变为了数组中所有元素变为数组中最小元素需要的次数，先获取最小值，然后差值求和</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">MinMoves</span>(<span class="params"><span class="built_in">int</span>[] nums</span>)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> minNum = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="built_in">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//此处用于获取数组中的最小元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; nums.Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        minNum = Math.Min(minNum, nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//差值求和</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt;nums.Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        result += (nums[i]=minNum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-870.优势洗牌</title>
    <url>/2022/10/10/Leetcode-870-%E4%BC%98%E5%8A%BF%E6%B4%97%E7%89%8C/</url>
    <content><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定两个大小相等的数组 nums1 和 nums2，nums1 相对于 nums2 的优势可以用满足 nums1[i] &gt; nums2[i] 的索引 i 的数目来描述。</p>
<p>返回 nums1 的任意排列，使其相对于 nums2 的优势最大化。</p>
<span id="more"></span>

<h4 id="示例-1："><a href="#示例-1：" class="headerlink" title="示例 1："></a>示例 1：</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">输入：nums1 = [2,7,11,15], nums2 = [1,10,4,11]</span><br><span class="line">输出：[2,11,7,15]</span><br></pre></td></tr></table></figure>
<h4 id="示例-2："><a href="#示例-2：" class="headerlink" title="示例 2："></a>示例 2：</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">输入：nums1 = [12,24,8,32], nums2 = [13,25,32,11]</span><br><span class="line">输出：[24,32,8,12]</span><br></pre></td></tr></table></figure>

<ul>
<li>提示：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1 &lt;= nums1.length &lt;= 105</span><br><span class="line">nums2.length == nums1.length</span><br><span class="line">0 &lt;= nums1[i], nums2[i] &lt;= 109</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>依据题目，要想获取优势最大化，使用田忌赛马策略，首先将数组nums1进行排序，然后获取nums2排序后的下标数组<br>然后使用双指针的策略，遍历数组，将nums1[i]与nums2[下标]进行比较，若nums1[i]较大，则赋值到下标sort_Nums2_Index[start]处，并移动start，若nums1[i]较小，则赋值到下标sort_Nums2_Index[end]处，并移动end。采用田忌赛马策略，若我的最小比你的最小大，则对上你的最小，若我的最小比你的最小小，则对上你的最大。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span>[] <span class="title">AdvantageCount</span>(<span class="params"><span class="built_in">int</span>[] nums1, <span class="built_in">int</span>[] nums2</span>)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//将数组nums1进行排序</span></span><br><span class="line">    Array.Sort(nums1);</span><br><span class="line">    <span class="built_in">int</span>[] result = <span class="keyword">new</span> <span class="built_in">int</span>[nums1.Length];</span><br><span class="line">    <span class="built_in">int</span>[] sort_Nums2_Index = <span class="keyword">new</span> <span class="built_in">int</span>[nums1.Length];</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; nums1.Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        sort_Nums2_Index[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取nums2排序后的下标数组</span></span><br><span class="line">    Array.Sort(sort_Nums2_Index, (i, j) =&gt; nums2[i] - nums2[j]);</span><br><span class="line">    <span class="built_in">int</span> start = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">int</span> end = nums1.Length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; nums1.Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums1[i] &gt; nums2[sort_Nums2_Index[start]])</span><br><span class="line">        &#123;</span><br><span class="line">            result[sort_Nums2_Index[start]] = nums1[i];</span><br><span class="line">            start++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            result[sort_Nums2_Index[end]] = nums1[i];</span><br><span class="line">            end--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-769-最多能完成排序的块</title>
    <url>/2022/10/13/Leetcode-769-%E6%9C%80%E5%A4%9A%E8%83%BD%E5%AE%8C%E6%88%90%E6%8E%92%E5%BA%8F%E7%9A%84%E5%9D%97/</url>
    <content><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个长度为<code>n</code>的整数数组<code>arr</code>，它表示在<code>[0, n - 1]</code>范围内的整数的排列。</p>
<p>我们将<code>arr</code>分割成若干<code>块</code>(即分区)，并对每个块单独排序。将它们连接起来后，使得连接的结果和按升序排序后的原数组相同。</p>
<p>返回数组能分成的最多块数量。</p>
<span id="more"></span>

<h4 id="示例-1："><a href="#示例-1：" class="headerlink" title="示例 1："></a>示例 1：</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">输入: arr = [4,3,2,1,0]</span><br><span class="line">输出: 1</span><br><span class="line">解释:</span><br><span class="line">将数组分成2块或者更多块，都无法得到所需的结果。</span><br><span class="line">例如，分成 [4, 3], [2, 1, 0] 的结果是 [3, 4, 0, 1, 2]，这不是有序的数组。</span><br></pre></td></tr></table></figure>

<h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2:"></a>示例 2:</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">输入: arr = [1,0,2,3,4]</span><br><span class="line">输出: 4</span><br><span class="line">解释:</span><br><span class="line">我们可以把它分成两块，例如 [1, 0], [2, 3, 4]。</span><br><span class="line">然而，分成 [1, 0], [2], [3], [4] 可以得到最多的块数。</span><br></pre></td></tr></table></figure>

<ul>
<li>提示<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">n == arr.length</span><br><span class="line">1 &lt;= n &lt;= 10</span><br><span class="line">0 &lt;= arr[i] &lt; n</span><br><span class="line">arr 中每个元素都 不同</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>依据题意，要获取分区后分别升序排序的块连接后与原数组升序结果一致，需要获取前<code>k+1</code>个数满足[0,k],即前k+1个数中最大的数为<code>k</code>的个数。<br>例如对于数组[1,2,0,3],遍历数组，最大的数初始化为arr[0]，不满足前1个数中最大的数为0，不满足，arr[1]&#x3D;&#x3D;2,不满足前2个数中最大的数为1，arr[2]&#x3D;&#x3D;0,满足前3个数中最大的数为2，result++，arr[3]&#x3D;&#x3D;3,满足前4个数中最大的数为3,result++;</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">MaxChunksToSorted</span>(<span class="params"><span class="built_in">int</span>[] arr</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">int</span> maxNum = arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; arr.Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        maxNum = Math.Max(maxNum, arr[i]);</span><br><span class="line">        <span class="keyword">if</span> (i == maxNum) </span><br><span class="line">        &#123;                    </span><br><span class="line">            result++;                    </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-76-最小覆盖子串</title>
    <url>/2022/10/21/Leetcode-76-%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%AD%90%E4%B8%B2/</url>
    <content><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个字符串<code>s</code>、一个字符串<code>t</code>。返回<code>s</code>中涵盖<code>t</code>所有字符的最小子串。如果<code>s</code>中不存在涵盖<code>t</code>所有字符的子串，则返回空字符串<code>&quot;&quot;</code>。</p>
<span id="more"></span>

<p>注意：</p>
<p>对<code>t</code>中重复字符，我们寻找的子字符串中该字符数量必须不少于<code>t</code>中该字符数量。<br>如果<code>s</code>中存在这样的子串，我们保证它是唯一的答案。</p>
<h4 id="示例-1："><a href="#示例-1：" class="headerlink" title="示例 1："></a>示例 1：</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">输入：s = <span class="string">&quot;ADOBECODEBANC&quot;</span>, t = <span class="string">&quot;ABC&quot;</span></span><br><span class="line">输出：<span class="string">&quot;BANC&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="示例-2："><a href="#示例-2：" class="headerlink" title="示例 2："></a>示例 2：</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">输入：s = <span class="string">&quot;a&quot;</span>, t = <span class="string">&quot;a&quot;</span></span><br><span class="line">输出：<span class="string">&quot;a&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="示例-3"><a href="#示例-3" class="headerlink" title="示例 3:"></a>示例 3:</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">输入: s = <span class="string">&quot;a&quot;</span>, t = <span class="string">&quot;aa&quot;</span></span><br><span class="line">输出: <span class="string">&quot;&quot;</span></span><br><span class="line">解释: t 中两个字符 <span class="string">&#x27;a&#x27;</span> 均应包含在 s 的子串中，</span><br><span class="line">因此没有符合条件的子字符串，返回空字符串。</span><br></pre></td></tr></table></figure>

<ul>
<li>提示<br>1 &lt;&#x3D; s.length, t.length &lt;&#x3D; 105<br>s 和 t 由英文字母组成</li>
</ul>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>此题采用滑动窗口思想</p>
<ul>
<li>定义start,end&#x3D;0，为我们初始的滑动窗口</li>
<li>开始循环遍历整个数组元素，判断当前end指针是否超过整个数组的长度，是退出循环，否则执行第3步</li>
<li>然后end指针开始向右移动一个长度，并更新窗口内的区间数据</li>
<li>当窗口区间的数据满足我们的要求时，右指针end就保持不变，左指针start开始移动，直到移动到一个不满足要求的区间时，start不再移动位置</li>
<li>执行第2步</li>
</ul>
<p>此题的重点在于如何判断数据满足条件，即<code>s</code>的字串涵盖<code>t</code>所有字符<br>此处采用的是定义一个长度为128的数组用于存放字符出现的次数，此处也可优化，根据提示由英文字母组成，可简化数组长度<br>    - 先将目标字符串的字符初始到数组中<br>    - 遍历s，即滑动窗口并更新s数组中的元素<br>    - 当t中元素不为0时，判断s中元素是否大于t中元素值</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">string</span> <span class="title">MinWindow</span>(<span class="params"><span class="built_in">string</span> s, <span class="built_in">string</span> t</span>)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span>[] sArray = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">128</span>];</span><br><span class="line">    <span class="built_in">int</span>[] tArray = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">128</span>];</span><br><span class="line">    <span class="built_in">string</span> result = <span class="built_in">string</span>.Empty;</span><br><span class="line">    <span class="built_in">int</span> start = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">int</span> end = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; t.Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        tArray[t[i]] += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (end &lt; s.Length)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//移动左指针</span></span><br><span class="line">        sArray[s[end++]] += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (EqualsArray(sArray, tArray))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//更新result值</span></span><br><span class="line">            <span class="keyword">if</span> (result == <span class="built_in">string</span>.Empty)</span><br><span class="line">            &#123;</span><br><span class="line">                result = s.Substring(start, end - start);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                result = end - start &lt; result.Length ? s.Substring(start, end - start) : result;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//移动右指针</span></span><br><span class="line">            sArray[s[start++]] -= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//此函数用于判断此时s的字串是否包含t中所有元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">EqualsArray</span>(<span class="params"><span class="built_in">int</span>[] sArray, <span class="built_in">int</span>[] tArray</span>)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; tArray.Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (tArray[i] != <span class="number">0</span> &amp;&amp; tArray[i] &gt; sArray[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-902-最大为N的数字组合</title>
    <url>/2022/10/18/Leetcode-902-%E6%9C%80%E5%A4%A7%E4%B8%BAN%E7%9A%84%E6%95%B0%E5%AD%97%E7%BB%84%E5%90%88/</url>
    <content><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个按<strong>非递减顺序</strong>排列的数字数组<code>digits</code>。你可以用任意次数<code>digits[i]</code>来写的数字。例如，如果<code>digits</code>&#x3D;<code>[&#39;1&#39;,&#39;3&#39;,&#39;5&#39;]</code>，我们可以写数字，如<code>&#39;13&#39;</code>,<code>&#39;551&#39;</code>, 和<code>&#39;1351315&#39;</code>。</p>
<p>返回 可以生成的小于或等于给定整数<code>n</code>的正整数的个数 。</p>
<span id="more"></span>

<h4 id="示例-1："><a href="#示例-1：" class="headerlink" title="示例 1："></a>示例 1：</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">输入：digits = [<span class="string">&quot;1&quot;</span>,<span class="string">&quot;3&quot;</span>,<span class="string">&quot;5&quot;</span>,<span class="string">&quot;7&quot;</span>], n = 100</span><br><span class="line">输出：20</span><br><span class="line">解释：</span><br><span class="line">可写出的 20 个数字是：</span><br><span class="line">1, 3, 5, 7, 11, 13, 15, 17, 31, 33, 35, 37, 51, 53, 55, 57, 71, 73, 75, 77.</span><br></pre></td></tr></table></figure>

<h4 id="示例-2："><a href="#示例-2：" class="headerlink" title="示例 2："></a>示例 2：</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">输入：digits = [<span class="string">&quot;1&quot;</span>,<span class="string">&quot;4&quot;</span>,<span class="string">&quot;9&quot;</span>], n = 1000000000</span><br><span class="line">输出：29523</span><br><span class="line">解释：</span><br><span class="line">我们可以写 3 个一位数字，9 个两位数字，27 个三位数字，</span><br><span class="line">81 个四位数字，243 个五位数字，729 个六位数字，</span><br><span class="line">2187 个七位数字，6561 个八位数字和 19683 个九位数字。</span><br><span class="line">总共，可以使用D中的数字写出 29523 个整数。</span><br></pre></td></tr></table></figure>

<h4 id="示例-2：-1"><a href="#示例-2：-1" class="headerlink" title="示例 2："></a>示例 2：</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">输入：digits = [<span class="string">&quot;7&quot;</span>], n = 8</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>

<ul>
<li>提示<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1 &lt;= digits.length &lt;= 9</span><br><span class="line">digits[i].length == 1</span><br><span class="line">digits[i] 是从 <span class="string">&#x27;1&#x27;</span> 到 <span class="string">&#x27;9&#x27;</span> 的数</span><br><span class="line">digits 中的所有值都 不同 </span><br><span class="line">digits 按 非递减顺序 排列</span><br><span class="line">1 &lt;= n &lt;= 109</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>根据题目意思，我们将问题拆分为两个部分</p>
<ul>
<li><p>当构成的数位数小于目标数数位的时候，个数为digits.Length^Length（构成数数位），此时构成的数显然都比目标数要小</p>
<ul>
<li>例如示例2中，构成三位数字的个数为<code>3^3=27</code>,构成四位数字的个数为<code>3^4=81</code></li>
</ul>
</li>
<li><p>当构成的数位数等于目标数数位的时候，我们从前向后遍历目标数，并于digits中的数进行比较</p>
<ul>
<li>若digits中的数比遍历的数字小，使用临时变量<code>temp</code>存储数量<ul>
<li>此时使用这些数为开头的数都比目标数小，个数为temp*(digits.Length^(位数-1))</li>
</ul>
</li>
<li>若digits中的数和遍历的数字相等时，继续向后遍历，此时注意，若digits中的数都比遍历数字大的时候，停止遍历</li>
<li>例如  digits &#x3D; [“5”，”4” , “3”, “2”],  n &#x3D; 4167 时，比4小的数有两个，则有2 * 4^3&#x3D;2 * 64&#x3D;128,比1小的数没有，此时停止遍历。</li>
<li>遍历到最末尾的时候，若还存在和遍历数字相等的数，需要将结果+1</li>
</ul>
</li>
</ul>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">AtMostNGivenDigitSet</span>(<span class="params"><span class="built_in">string</span>[] digits, <span class="built_in">int</span> n</span>)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">int</span> tempAdd = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">string</span> target = n.ToString();</span><br><span class="line">    <span class="built_in">int</span> length = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">int</span>[] digitsTemp = <span class="keyword">new</span> <span class="built_in">int</span>[digits.Length];</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; digits.Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        digitsTemp[i] = <span class="built_in">int</span>.Parse(digits[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//当构成的数位数小于目标数数位的时候</span></span><br><span class="line">    <span class="keyword">while</span> (target.Length &gt; length) </span><br><span class="line">    &#123;</span><br><span class="line">        result += (<span class="built_in">int</span>)Math.Pow(digits.Length, length);</span><br><span class="line">        length++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//当构成的数位数等于目标数数位的时候</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; target.Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> temp = <span class="number">0</span>;</span><br><span class="line">        tempAdd = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">int</span> targetNum = <span class="built_in">int</span>.Parse(target[i].ToString());</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> j = <span class="number">0</span>; j &lt; digitsTemp.Length; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//若digits中的数比遍历的数字小，使用临时变量`temp`存储数量</span></span><br><span class="line">            <span class="keyword">if</span> (targetNum &gt; digitsTemp[j]) </span><br><span class="line">            &#123;</span><br><span class="line">                temp++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//若digits中的数和遍历的数字相等时，继续遍历</span></span><br><span class="line">            <span class="keyword">if</span> (targetNum == digitsTemp[j]) </span><br><span class="line">            &#123;</span><br><span class="line">                tempAdd++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        result += temp*(<span class="built_in">int</span>)Math.Pow(digits.Length, length - i - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//若digits中的数都比遍历数字大的时候，停止遍历</span></span><br><span class="line">        <span class="keyword">if</span> (tempAdd == <span class="number">0</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;                </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//遍历到最末尾的时候，若还存在和遍历数字相等的数，需要将结果，即加上tempAdd,此时tempAdd为1</span></span><br><span class="line">    <span class="keyword">return</span> result+tempAdd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-904-水果成篮</title>
    <url>/2022/10/17/Leetcode-904-%E6%B0%B4%E6%9E%9C%E6%88%90%E7%AF%AE/</url>
    <content><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>你正在探访一家农场，农场从左到右种植了一排果树。这些树用一个整数数组<code>fruits</code>表示，其中<code>fruits[i]</code>是第<code>i</code>棵树上的水果 种类 。</p>
<span id="more"></span>

<p>你想要尽可能多地收集水果。然而，农场的主人设定了一些严格的规矩，你必须按照要求采摘水果：</p>
<ul>
<li>你只有<code>两个</code>篮子，并且每个篮子只能装 单一类型 的水果。每个篮子能够装的水果总量没有限制。</li>
<li>你可以选择任意一棵树开始采摘，你必须从 每棵 树（包括开始采摘的树）上 恰好摘一个水果 。采摘的水果应当符合篮子中的水果类型。每采摘一次，你将会向右移动到下一棵树，并继续采摘。</li>
<li>一旦你走到某棵树前，但水果不符合篮子的水果类型，那么就必须停止采摘。</li>
</ul>
<p>给你一个整数数组<code>fruits</code>，返回你可以收集的水果的<code>最大</code>数目。</p>
<h4 id="示例-1："><a href="#示例-1：" class="headerlink" title="示例 1："></a>示例 1：</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">输入：fruits = [1,2,1]</span><br><span class="line">输出：3</span><br><span class="line">解释：可以采摘全部 3 棵树。</span><br></pre></td></tr></table></figure>

<h4 id="示例-2："><a href="#示例-2：" class="headerlink" title="示例 2："></a>示例 2：</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">输入：fruits = [0,1,2,2]</span><br><span class="line">输出：3</span><br><span class="line">解释：可以采摘 [1,2,2] 这三棵树。</span><br><span class="line">如果从第一棵树开始采摘，则只能采摘 [0,1] 这两棵树。</span><br></pre></td></tr></table></figure>

<h4 id="示例-3："><a href="#示例-3：" class="headerlink" title="示例 3："></a>示例 3：</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">输入：fruits = [1,2,3,2,2]</span><br><span class="line">输出：4</span><br><span class="line">解释：可以采摘 [2,3,2,2] 这四棵树。</span><br><span class="line">如果从第一棵树开始采摘，则只能采摘 [1,2] 这两棵树。</span><br></pre></td></tr></table></figure>

<h4 id="示例-4："><a href="#示例-4：" class="headerlink" title="示例 4："></a>示例 4：</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">输入：fruits = [3,3,3,1,2,1,1,2,3,3,4]</span><br><span class="line">输出：5</span><br><span class="line">解释：可以采摘 [1,2,1,1,2] 这五棵树。</span><br></pre></td></tr></table></figure>

<ul>
<li>提示<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1 &lt;= fruits.length &lt;= 105</span><br><span class="line">0 &lt;= fruits[i] &lt; fruits.length</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>此题采用滑动窗口算法的思路</p>
<ul>
<li>定义start,end&#x3D;0，为我们初始的滑动窗口</li>
<li>开始循环遍历整个数组元素，判断当前end指针是否超过整个数组的长度，是退出循环，否则执行第3步</li>
<li>然后end指针开始向右移动一个长度，并更新窗口内的区间数据</li>
<li>当窗口区间的数据不满足我们的要求时，右指针end就保持不变，左指针start开始移动，直到移动到一个满足要求的区间时，start不再移动位置</li>
<li>执行第2步</li>
</ul>
<p><code>例</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fruits = [3,3,3,1,2,1,1,2,3,3,4]</span><br><span class="line">end 移动 窗口元素为[3]，满足仅有两个元素的要求</span><br><span class="line">end 移动 窗口元素为[3,3]，满足仅有两个元素的要求</span><br><span class="line">end 移动 窗口元素为[3,3,3]，满足仅有两个元素的要求</span><br><span class="line">end 移动 窗口元素为[3,3,3,1]，满足仅有两个元素的要求     result=4</span><br><span class="line">end 移动 窗口元素为[3,3,3,1,2]，不满足仅有两个元素的要求 </span><br><span class="line">start 移动 窗口元素为[3,3,1,2]，不满足仅有两个元素的要求</span><br><span class="line">start 移动 窗口元素为[3,1,2]，不满足仅有两个元素的要求</span><br><span class="line">start 移动 窗口元素为[1,2]，满足仅有两个元素的要求</span><br><span class="line">end 移动 窗口元素为[1,2,1]，满足仅有两个元素的要求</span><br><span class="line">end 移动 窗口元素为[1,2,1,1]，满足仅有两个元素的要求</span><br><span class="line">end 移动 窗口元素为[1,2,1,1,2]，满足仅有两个元素的要求      result=5</span><br><span class="line">end 移动 窗口元素为[1,2,1,1,2,3]，不满足仅有两个元素的要求</span><br><span class="line">start 移动 窗口元素为[2,1,1,2,3]，不满足仅有两个元素的要求</span><br><span class="line">start 移动 窗口元素为[1,1,2,3]，不满足仅有两个元素的要求</span><br><span class="line">start 移动 窗口元素为[1,2,3]，不满足仅有两个元素的要求</span><br><span class="line">start 移动 窗口元素为[2,3]，满足仅有两个元素的要求</span><br><span class="line">end 移动 窗口元素为[2,3,3]，满足仅有两个元素的要求</span><br><span class="line">end 移动 窗口元素为[2,3,3,4]，不满足仅有两个元素的要求</span><br><span class="line">start 移动 窗口元素为[3,3,4]，满足仅有两个元素的要求</span><br><span class="line">结束</span><br></pre></td></tr></table></figure>

<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">TotalFruit</span>(<span class="params"><span class="built_in">int</span>[] fruits</span>)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> start = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">int</span> end = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">int</span> result = <span class="number">0</span>;</span><br><span class="line">    Dictionary&lt;<span class="built_in">int</span>, <span class="built_in">int</span>&gt; pairs = <span class="keyword">new</span> Dictionary&lt;<span class="built_in">int</span>, <span class="built_in">int</span>&gt;();</span><br><span class="line">    <span class="comment">//判断当前end指针是否超过整个数组的长度</span></span><br><span class="line">    <span class="keyword">while</span> (end &lt; fruits.Length) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> temp = fruits[end++];</span><br><span class="line">        <span class="keyword">if</span> (!pairs.ContainsKey(temp))</span><br><span class="line">        &#123;</span><br><span class="line">            pairs.Add(temp, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            pairs[temp] += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当窗口区间的数据不满足我们的要求时，左指针start开始移动</span></span><br><span class="line">        <span class="keyword">while</span> (pairs.Count &gt; <span class="number">2</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">int</span> tempend = fruits[start++];</span><br><span class="line">            <span class="keyword">if</span> (pairs[tempend] == <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                pairs.Remove(tempend);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">            &#123;</span><br><span class="line">                pairs[tempend] -= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        result = Math.Max(end-start, result);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Linq</title>
    <url>/2022/10/12/Linq/</url>
    <content><![CDATA[<h3 id="LINQ介绍"><a href="#LINQ介绍" class="headerlink" title="LINQ介绍"></a>LINQ介绍</h3><h4 id="什么是LINQ"><a href="#什么是LINQ" class="headerlink" title="什么是LINQ"></a>什么是LINQ</h4><p>LINQ是英文Language Integrated Query的缩写，中文译为语言集成查询</p>
<p>LINQ(语言集成查询)是C#、VB.NET以及F#中的统一查询语法，用以检索来自不同数据源和格式的数据。它集成在c#、VB以及F#语言中，从而消除了编程语言和数据库之间的不匹配，并为不同类型的数据源提供了一个单一的查询接口。</p>
<span id="more"></span>

<h4 id="LINQ的优势"><a href="#LINQ的优势" class="headerlink" title="LINQ的优势"></a>LINQ的优势</h4><ul>
<li>熟悉的语言：C#，VB.NET，F#开发者无需学习额外的语法</li>
<li>写更少的代码：与更传统的方法相比，LINQ减少了需要编写的代码量</li>
<li>可读性更高：LINQ使代码更具可读性，因此其他开发人员可以轻松地理解和维护它</li>
<li>标准化方式查询多个数据源：可以使用同样的LINQ语法查询多个数据源</li>
<li>编译时查询的安全性：LINQ查询支持在编译时提供对象的类型检查</li>
<li>智能感知的支持：LINQ为泛型集合提供了智能感知</li>
<li>数据重塑：LINQ查询可以检索并返回不同类型的数据</li>
</ul>
<h3 id="LINQ标准查询操作符"><a href="#LINQ标准查询操作符" class="headerlink" title="LINQ标准查询操作符"></a>LINQ标准查询操作符</h3><h4 id="LINQ操作符之Where"><a href="#LINQ操作符之Where" class="headerlink" title="LINQ操作符之Where"></a>LINQ操作符之Where</h4><p>Where操作符(Linq扩展方法)基于给定的条件表达式过滤集合，并返回一个新的集合。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="meta">### 查询订单中价格大于2000 且为线上的订单</span></span><br><span class="line"><span class="keyword">var</span> list = order.Where(e =&gt; e.Price &gt; <span class="number">2000</span>).Where(e =&gt; e.Source == <span class="string">&quot;线上&quot;</span>).ToList();</span><br></pre></td></tr></table></figure>
<p><code>tips:</code>需要注意的是LINQ查询具有<code>延迟执行</code>的特性</p>
<ul>
<li>它是指查询操作并不是在查询运算符定义的时候执行，真正使用集合中的数据时才执行，例如遍历数据集合时调用MoveNext方法会触发查询操作</li>
<li>当返回值为IEnumerable<TSource>、IEnumerable&lt;IGrouping&lt;TKey, TSource&gt;&gt;和IOrderedEnumerable<TSource>的时候，Linq为延迟执行。实际上上述三个返回值类型都实现了IEnumerable<T>(公开枚举数)这个接口，yield return的返回值就是IEnumerable<T>，所以，当Linq查询操作符的返回值为上述三个类型时，查询为延迟查询，其他为立即执行。</li>
<li>如何让查询立即执行呢，可以使用LINQ内置所提供的转换操作的定义：ToArray(转换为数组)、ToDictionary(转换为字典)、ToList(转换为集合)</li>
<li>在使用的时候要注意这个特性，避免重复查询出现</li>
</ul>
<h4 id="LINQ操作符之OfType"><a href="#LINQ操作符之OfType" class="headerlink" title="LINQ操作符之OfType"></a>LINQ操作符之OfType</h4><p>OfType操作符用于根据指定的类型过滤IEnumerable中的元素，它返回一个包含指定类型的IEnumerable<T>的子集合。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="meta">### 从中筛选出类型为int类型的元素</span></span><br><span class="line"><span class="keyword">var</span> lists = <span class="keyword">new</span> List&lt;<span class="built_in">object</span>&gt; &#123; <span class="string">&quot;asdas&quot;</span>, <span class="string">&quot;asdadf&quot;</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">10.5</span>, <span class="number">15.45</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> result = lists.OfType&lt;<span class="built_in">string</span>&gt;().ToList();</span><br></pre></td></tr></table></figure>

<h4 id="LINQ操作符之OrderBy和OrderByDescending"><a href="#LINQ操作符之OrderBy和OrderByDescending" class="headerlink" title="LINQ操作符之OrderBy和OrderByDescending"></a>LINQ操作符之OrderBy和OrderByDescending</h4><p>在LINQ的查询语法中，OrderBy按升序或降序对集合的值进行排序。默认情况下，它按升序对集合进行排序，因为ascending关键字在这里是可选的。使用descending关键字对集合进行降序排序。</p>
<p>在LINQ的方法语法中，OrderBy则只能按升序对集合的值进行排序，而OrderByDescending则按降序排序，并且OrderByDescending只适用于方法语法中。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="meta">### 依据订单的价格升序排列</span></span><br><span class="line"><span class="keyword">var</span> result = list.OrderBy(e =&gt; e.Price).ToList();</span><br></pre></td></tr></table></figure>

<h4 id="LINQ操作符之ThenBy和ThenByDescending"><a href="#LINQ操作符之ThenBy和ThenByDescending" class="headerlink" title="LINQ操作符之ThenBy和ThenByDescending"></a>LINQ操作符之ThenBy和ThenByDescending</h4><p>OrderBy()方法根据指定的字段按升序对集合进行排序。在OrderBy之后使用ThenBy()方法对另一个字段上的集合按升序排序。LINQ首先根据OrderBy方法指定的主字段对集合进行排序，然后根据ThenBy方法指定的次字段对结果集合进行升序排序。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="meta">### 先依据的价格升序排列，再根据订单创建时间降序排列</span></span><br><span class="line"><span class="keyword">var</span> result = list.OrderBy(e=&gt;e.Price).ThenByDescending(e=&gt;e.CreatedAt).ToList();</span><br></pre></td></tr></table></figure>

<h4 id="LINQ操作符之-GroupBy"><a href="#LINQ操作符之-GroupBy" class="headerlink" title="LINQ操作符之 GroupBy"></a>LINQ操作符之 GroupBy</h4><p>分组操作符根据给定的键创建一组元素。这个组包含在一个特殊类型的集合中，该集合实现了一个IGrouping&lt;TKey,TSource&gt;接口，其中TKey是一个键值，在这个键值上形成了组，而TSource是与分组键值匹配的元素集合。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="meta">### 依据订单来源进行分组排序</span></span><br><span class="line"><span class="keyword">var</span> result = list.GroupBy(e=&gt;e.Source);</span><br><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> item <span class="keyword">in</span> result)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(item.Key);</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">var</span> <span class="keyword">value</span> <span class="keyword">in</span> item)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(JsonConvert.SerializeObject(<span class="keyword">value</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同时可以依据多字段进行分组排序</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="meta">### 依据订单及用户分组排序</span></span><br><span class="line"><span class="keyword">var</span> result = list.GroupBy(e=&gt;<span class="keyword">new</span> TypeA(e.Source,e.Customer)).ToList();</span><br></pre></td></tr></table></figure>

<h4 id="LINQ操作符之ToLookup"><a href="#LINQ操作符之ToLookup" class="headerlink" title="LINQ操作符之ToLookup"></a>LINQ操作符之ToLookup</h4><p>ToLookup操作符是一个扩展方法，它用于从源集合中提取一组键&#x2F;值对。在这里，结果集合中的每个元素都是一个通用的Lookup对象，该对象包含与该键匹配的键和子项。<br>LINQ方法语法中，ToLookup与GroupBy相同，唯一的区别是GroupBy的执行是延迟的，而ToLookup的执行是立即的。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> result = list.ToLookup(e=&gt;e.Source)</span><br></pre></td></tr></table></figure>

<h4 id="LINQ操作符之Join"><a href="#LINQ操作符之Join" class="headerlink" title="LINQ操作符之Join"></a>LINQ操作符之Join</h4><p>内部连接生成一个结果集，其中第一个集合的每个元素对于第二个集合中的每个匹配元素都出现一次。如果第一个集合中的元素在第二个集合中没有任何匹配的元素，那么它就不会出现在结果集中。<br>内连接仅用于从两个数据源返回匹配的元素，而从结果集中删除不匹配的元素，如图所示<br><img src="https://img-blog.csdnimg.cn/c7059d53e12a48e0a4751e41915267b2.png" alt="Linq内连接"></p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> result = customers.                <span class="comment">// 1.外部数据源</span></span><br><span class="line">    Join(</span><br><span class="line">    addresses,                         <span class="comment">// 2.内部数据源</span></span><br><span class="line">    c =&gt; c.AddressId,                  <span class="comment">// 3.外部键选择器</span></span><br><span class="line">    e =&gt; e.Id,                         <span class="comment">// 4.内部键选择器</span></span><br><span class="line">    (customers, addresses) =&gt; <span class="keyword">new</span>      <span class="comment">// 5.期望返回的结果集选择器</span></span><br><span class="line">    &#123;</span><br><span class="line">        name = customers.Name,</span><br><span class="line">        province = addresses.Province,</span><br><span class="line">        city = addresses.City,</span><br><span class="line">        district = addresses.District,</span><br><span class="line">        street = addresses.Street</span><br><span class="line">    &#125;</span><br><span class="line">    ).ToList();</span><br></pre></td></tr></table></figure>
<p>外部数据源中的外部键起到驱动作用，从内部中寻找匹配的数据，并按照结果集选择器中的去返回</p>
<h4 id="LINQ操作符之GroupJoin"><a href="#LINQ操作符之GroupJoin" class="headerlink" title="LINQ操作符之GroupJoin"></a>LINQ操作符之GroupJoin</h4><p>GroupJoin基本上是用来生成分组数据结构的。来自第一个数据源的每个项都与来自第二个数据源的一组相关项配对</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> customers = FakeData.Customers;</span><br><span class="line"><span class="keyword">var</span> addresses = FakeData.Addresses;</span><br><span class="line"><span class="keyword">var</span> result = addresses.                <span class="comment">// 1.外部数据源</span></span><br><span class="line">    GroupJoin(</span><br><span class="line">    customers,                         <span class="comment">// 2.内部数据源</span></span><br><span class="line">    c =&gt; c.Id,                         <span class="comment">// 3.外部键选择器</span></span><br><span class="line">    e =&gt; e.AddressId,                  <span class="comment">// 4.内部键选择器</span></span><br><span class="line">    (addresses, customers) =&gt; <span class="keyword">new</span>      <span class="comment">// 5.期望返回的结果集选择器</span></span><br><span class="line">    &#123;</span><br><span class="line">        addresses,</span><br><span class="line">        customers</span><br><span class="line">    &#125;</span><br><span class="line">    ).ToList();</span><br></pre></td></tr></table></figure>

<h4 id="LINQ操作符之Select"><a href="#LINQ操作符之Select" class="headerlink" title="LINQ操作符之Select"></a>LINQ操作符之Select</h4><p>投影是用于从数据源中选择数据的一种机制。你可以选择与数据源相同形式的数据(即原始数据处于其原始状态)。还可以通过对数据执行一些操作来创建新的数据形式。<br>LINQ中的Select操作符也允许我们指定我们想要检索的属性，你是想检索所有的属性，还是一些你需要在Select操作符中指定的属性。标准的LINQ选择操作符也允许我们执行一些计算。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> result = orders.Select(e =&gt; e.Customer).ToList();</span><br></pre></td></tr></table></figure>

<h4 id="LINQ操作符之SelectMany"><a href="#LINQ操作符之SelectMany" class="headerlink" title="LINQ操作符之SelectMany"></a>LINQ操作符之SelectMany</h4><p>LINQ的SelectMany操作符是将序列的每个元素投影到IEnumerable<T>并将结果序列合并为一个序列。这意味着SelectMany操作符组合来自一系列结果的记录，然后将其转换为一个结果。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> result = petOwners</span><br><span class="line">        .SelectMany(petOwner =&gt; petOwner.Pets, (petOwner, petName) =&gt; <span class="keyword">new</span> &#123; petOwner.Name, petName &#125;).Where(e=&gt;e.petName.Contains(<span class="string">&quot;S&quot;</span>));</span><br></pre></td></tr></table></figure>

<h4 id="LINQ操作符之All"><a href="#LINQ操作符之All" class="headerlink" title="LINQ操作符之All"></a>LINQ操作符之All</h4><p>C#中LINQ的All操作符用于检查数据源的所有元素是否满足给定的条件。如果所有元素都满足条件，则返回true，否则返回false。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="meta">### 判断数组中是否所有元素都大于20</span></span><br><span class="line"><span class="keyword">var</span> numbers = <span class="keyword">new</span>[] &#123; <span class="number">1</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">16</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">56</span>, <span class="number">80</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> areAllNumbersGreaterThan10 = numbers.All(x =&gt; x &gt; <span class="number">20</span>);</span><br></pre></td></tr></table></figure>

<h4 id="LINQ操作符之Any"><a href="#LINQ操作符之Any" class="headerlink" title="LINQ操作符之Any"></a>LINQ操作符之Any</h4><p>C#中LINQ的Any操作符用于检查数据源中是否至少有一个元素满足给定的条件。如果任何元素满足给定条件，则返回true，否则返回false。它也用于检查一个集合是否包含一些数据。这意味着它还检查集合的长度。如果它包含任何数据，则返回true，否则返回false。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="meta">### 判断数组中是否存在元素大于20</span></span><br><span class="line"><span class="keyword">var</span> numbers = <span class="keyword">new</span>[] &#123; <span class="number">1</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">16</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">56</span>, <span class="number">80</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> areAllNumbersGreaterThan10 = numbers.All(x =&gt; x &gt; <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">### 判断集合中是否存在元素</span></span><br><span class="line">numbers.Any();</span><br></pre></td></tr></table></figure>

<h4 id="LINQ操作符之Contains"><a href="#LINQ操作符之Contains" class="headerlink" title="LINQ操作符之Contains"></a>LINQ操作符之Contains</h4><p>Contains操作符检查指定的元素是否存在于集合中，并返回一个布尔值。<br>Contains扩展方法有两个重载，第一个重载方法需要传入一个在集合中检索的值，第二个重载方法需要传入一个附加的IEqualityComparer参数来进行自定义的相等性比较器。</p>
<p>Contains扩展方法只比较对象的引用，而不是对象的实际值。因此，为了比较student对象的值，需要通过实现IEqualityComparer接口创建一个类，该接口比较两个student对象的值并返回布尔值。</p>
<h4 id="LINQ操作符之Aggregate"><a href="#LINQ操作符之Aggregate" class="headerlink" title="LINQ操作符之Aggregate"></a>LINQ操作符之Aggregate</h4><p>Aggregate具有三种重载</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TSource <span class="title">Aggregate</span>&lt;<span class="title">TSource</span>&gt;(<span class="params"><span class="keyword">this</span> IEnumerable&lt;TSource&gt; source, </span></span></span><br><span class="line"><span class="params"><span class="function">                                         Func&lt;TSource, TSource, TSource&gt; func</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TAccumulate <span class="title">Aggregate</span>&lt;<span class="title">TSource</span>, <span class="title">TAccumulate</span>&gt;(<span class="params"><span class="keyword">this</span> IEnumerable&lt;TSource&gt; source, </span></span></span><br><span class="line"><span class="params"><span class="function">                                         TAccumulate seed, </span></span></span><br><span class="line"><span class="params"><span class="function">                                         Func&lt;TAccumulate, TSource, TAccumulate&gt; func</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TResult <span class="title">Aggregate</span>&lt;<span class="title">TSource</span>, <span class="title">TAccumulate</span>, <span class="title">TResult</span>&gt;(<span class="params"><span class="keyword">this</span> IEnumerable&lt;TSource&gt; source, </span></span></span><br><span class="line"><span class="params"><span class="function">                                         TAccumulate seed, </span></span></span><br><span class="line"><span class="params"><span class="function">                                         Func&lt;TAccumulate, TSource, TAccumulate&gt; func, </span></span></span><br><span class="line"><span class="params"><span class="function">                                         Func&lt;TAccumulate, TResult&gt; resultSelector</span>)</span>;</span><br></pre></td></tr></table></figure>

<h4 id="LINQ操作符之Average"><a href="#LINQ操作符之Average" class="headerlink" title="LINQ操作符之Average"></a>LINQ操作符之Average</h4><p>LINQ的Average方法用于计算应用该方法的集合中的数值的平均值。这个Average方法可以返回可为空或不可为空的十进制、浮点或双精度值。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> numbers = <span class="keyword">new</span>[] &#123; <span class="number">20</span>, <span class="number">30</span>, <span class="number">50</span>, <span class="number">60</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> avg = numbers.Average();</span><br></pre></td></tr></table></figure>

<h4 id="LINQ操作符之Count"><a href="#LINQ操作符之Count" class="headerlink" title="LINQ操作符之Count"></a>LINQ操作符之Count</h4><p>Count操作符用以返回集合中元素的数量或满足给定条件的元素的数量</p>
<h4 id="LINQ操作符之Max、Min、Sum"><a href="#LINQ操作符之Max、Min、Sum" class="headerlink" title="LINQ操作符之Max、Min、Sum"></a>LINQ操作符之Max、Min、Sum</h4><p>LINQ的Max()方法用以返回集合中最大的数字元素。<br>Min操作符与Max操作符类似，只是Min用以返回集合中最小的数字元素。<br>LINQ的Max()方法用以计算集合中数值项的和。</p>
<h4 id="LINQ操作符之元素操作符"><a href="#LINQ操作符之元素操作符" class="headerlink" title="LINQ操作符之元素操作符"></a>LINQ操作符之元素操作符</h4><table>
<thead>
<tr>
<th>操作符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>ElementAt</td>
<td>返回集合中指定索引处的元素。</td>
</tr>
<tr>
<td>ElementAtOrDefault</td>
<td>返回集合中指定索引处的元素，如果索引超出范围则返回默认值。</td>
</tr>
<tr>
<td>First</td>
<td>返回集合的第一个元素，或满足条件的第一个元素。</td>
</tr>
<tr>
<td>FirstOrDefault</td>
<td>返回集合的第一个元素，或满足条件的第一个元素。如果索引超出范围，返回默认值。</td>
</tr>
<tr>
<td>Last</td>
<td>返回集合的最后一个元素，或满足条件的最后一个元素</td>
</tr>
<tr>
<td>LastOrDefault</td>
<td>返回集合的最后一个元素，或满足条件的最后一个元素。如果不存在这样的元素，则返回默认值。</td>
</tr>
<tr>
<td>Single</td>
<td>返回集合中的唯一元素，或满足条件的唯一元素。</td>
</tr>
<tr>
<td>SingleOrDefault</td>
<td>返回集合中的唯一元素，或满足条件的唯一元素。如果不存在这样的元素或集合不包含恰好一个元素，则返回默认值。</td>
</tr>
</tbody></table>
<h4 id="LINQ操作符之集合操作符"><a href="#LINQ操作符之集合操作符" class="headerlink" title="LINQ操作符之集合操作符"></a>LINQ操作符之集合操作符</h4><table>
<thead>
<tr>
<th>操作符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>Distinct</td>
<td>去掉集合的重复项</td>
</tr>
<tr>
<td>Except</td>
<td>返回两个集合的不同，第一个集合的元素不能出现在第二个集合中</td>
</tr>
<tr>
<td>Intersect</td>
<td>返回两个集合的交集，即元素同时出现在两个集合中</td>
</tr>
<tr>
<td>Union</td>
<td>返回两个序列中的唯一元素，这意味着出现在两个序列中的任何一个中的唯一元素</td>
</tr>
</tbody></table>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="meta">### 去重</span></span><br><span class="line"><span class="keyword">var</span> numbers = <span class="keyword">new</span>[] &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> result = numbers.Distinct();</span><br><span class="line"></span><br><span class="line"><span class="meta">### 返回两个集合的差值</span></span><br><span class="line"><span class="keyword">var</span> numbers = <span class="keyword">new</span>[] &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> numbers2 = <span class="keyword">new</span>[] &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">11</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> result = numbers.Except(numbers2);</span><br><span class="line"></span><br><span class="line"><span class="meta">### 返回两个集合的交集</span></span><br><span class="line"><span class="keyword">var</span> result = numbers.Intersect(numbers2);</span><br><span class="line"></span><br><span class="line"><span class="meta">### 返回两个集合的并集</span></span><br><span class="line"><span class="keyword">var</span> result = numbers.Union(numbers2);</span><br></pre></td></tr></table></figure>
<h4 id="LINQ操作符之切分操作符"><a href="#LINQ操作符之切分操作符" class="headerlink" title="LINQ操作符之切分操作符"></a>LINQ操作符之切分操作符</h4><table>
<thead>
<tr>
<th>操作符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>Take</td>
<td>从序列的开头返回指定数量的连续元素</td>
</tr>
<tr>
<td>TakeWhile</td>
<td>只要满足指定的条件，就会返回序列的元素。</td>
</tr>
<tr>
<td>Skip</td>
<td>跳过序列中指定数量的元素，然后返回剩余的元素。</td>
</tr>
<tr>
<td>SkipWhile</td>
<td>只要满足指定的条件，就会跳过序列的元素。</td>
</tr>
</tbody></table>
<p><code>tips:</code>TakeWhile和Where的区别在于，TakeWhile是从前往后计算，如果遇到不满足Func条件，则提前退出。</p>
<h4 id="LINQ操作符之连接操作符"><a href="#LINQ操作符之连接操作符" class="headerlink" title="LINQ操作符之连接操作符"></a>LINQ操作符之连接操作符</h4><p>Concat操作符用于连接两个序列，生成一个新序列。</p>
<h4 id="LINQ操作符之等式操作符"><a href="#LINQ操作符之等式操作符" class="headerlink" title="LINQ操作符之等式操作符"></a>LINQ操作符之等式操作符</h4><p>SequenceEqual()用于判断两个序列中的内容是否一致。</p>
<h4 id="LINQ操作符之生成操作符"><a href="#LINQ操作符之生成操作符" class="headerlink" title="LINQ操作符之生成操作符"></a>LINQ操作符之生成操作符</h4><table>
<thead>
<tr>
<th>操作符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>DefaultEmpty</td>
<td>返回指定序列的元素；如果序列为空，则返回单一实例集合中的类型参数的默认值。</td>
</tr>
<tr>
<td>Empty</td>
<td>初始化集合</td>
</tr>
<tr>
<td>Range</td>
<td>生成指定范围内的整数的序列</td>
</tr>
<tr>
<td>Repeat</td>
<td>生成包含一个重复值的序列</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>C#</category>
      </categories>
      <tags>
        <tag>Linq</tag>
      </tags>
  </entry>
  <entry>
    <title>NetCore-WebApi统一包装返回结果</title>
    <url>/2022/10/27/NetCore-WebApi%E7%BB%9F%E4%B8%80%E5%8C%85%E8%A3%85%E8%BF%94%E5%9B%9E%E7%BB%93%E6%9E%9C/</url>
    <content><![CDATA[<h5 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h5><p>在项目开发的过程中，在项目初期进行项目搭建的时候，应该尽可能让项目变得完善且更加好用，这一点涉及的方面很多，有许多在项目开发前期没有考虑周全导致后期维护成本大大增加，本文主要是对Net Core中返回结果统一包装的处理</p>
<span id="more"></span>

<h5 id="统一结果类分装"><a href="#统一结果类分装" class="headerlink" title="统一结果类分装"></a>统一结果类分装</h5><p>使返回结果结构统一，首先需要一个统一的返回结果进行包装，在项目开发过程中会有不同的返回结果产生，虽然结构可能一致，但是数据类型可能存在不一致，因此可以常用泛型进行处理，此处不使用Object主要是避免装箱&#x2F;拆箱的产生</p>
<h6 id="定义包装类"><a href="#定义包装类" class="headerlink" title="定义包装类"></a>定义包装类</h6><p>首先定义一个返回结果的包装类</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ApiReturn</span>&lt;<span class="title">T</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> StatusCode Status &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; = StatusCode.Success;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">string</span> message;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Message</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> !<span class="built_in">string</span>.IsNullOrEmpty(message) ? message : EnumHelper.GetEnumDescription(Status);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">set</span></span><br><span class="line">        &#123;</span><br><span class="line">            message = <span class="keyword">value</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> T Data &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">enum</span> StatusCode</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">Description(<span class="string">&quot;请求成功&quot;</span>)</span>]</span><br><span class="line">    Success = <span class="number">200</span>,</span><br><span class="line">    [<span class="meta">Description(<span class="string">&quot;请求失败&quot;</span>)</span>]</span><br><span class="line">    Fail = <span class="number">400</span>,</span><br><span class="line">    [<span class="meta">Description(<span class="string">&quot;请求异常&quot;</span>)</span>]</span><br><span class="line">    Error = <span class="number">500</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>上图中的EnumHelper类主要用于获取定义枚举类的Description</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">EnumHelper</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 获取当前枚举描述</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;enumValue&quot;&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span><span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">string</span> <span class="title">GetEnumDescription</span>(<span class="params">Enum enumValue</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            Type type = enumValue.GetType();</span><br><span class="line">            MemberInfo[] memInfo = type.GetMember(enumValue.ToString());</span><br><span class="line">            <span class="keyword">if</span> (<span class="literal">null</span> != memInfo &amp;&amp; memInfo.Length &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">object</span>[] attrs = memInfo[<span class="number">0</span>].GetCustomAttributes(<span class="keyword">typeof</span>(DescriptionAttribute), <span class="literal">false</span>);</span><br><span class="line">                <span class="keyword">if</span> (<span class="literal">null</span> != attrs &amp;&amp; attrs.Length &gt; <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">return</span> ((DescriptionAttribute)attrs[<span class="number">0</span>]).Description;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> enumValue.ToString();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Unknown&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这样就简单实现了返回结果的包装，下面简单使用一下</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ApiReturn&lt;<span class="built_in">string</span>&gt; <span class="title">Test</span>(<span class="params">[FromBody]<span class="built_in">string</span> username</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ApiReturn&lt;<span class="built_in">string</span>&gt; &#123;</span><br><span class="line">        Data = username                </span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h6><p>但是这种情况下我们每次都需要new 一个ApiReturn对象，我们可以将相应进行方法封装，简化我们在返回时需要传递的参数</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ApiReturn&lt;T&gt; <span class="title">SuccessResult</span>(<span class="params">T data</span>)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ApiReturn&lt;T&gt; &#123; Status = StatusCodes.Success, Data = data &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ApiReturn&lt;T&gt; <span class="title">FailResult</span>(<span class="params"><span class="built_in">string</span> message = <span class="literal">null</span></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ApiReturn&lt;T&gt; &#123; Status = StatusCodes.Fail, message = message &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ApiReturn&lt;T&gt; <span class="title">ErrorResult</span>(<span class="params"><span class="built_in">string</span> message = <span class="literal">null</span></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ApiReturn&lt;T&gt; &#123; Status = StatusCodes.Error, message = message &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通用返回</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ApiReturn&lt;T&gt; <span class="title">ResponseResult</span>(<span class="params">T data, StatusCodes code, <span class="built_in">string</span> message = <span class="literal">null</span></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ApiReturn&lt;T&gt; &#123; Status = code, Message = message, Data = data &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>简单使用</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ApiReturn&lt;<span class="built_in">string</span>&gt; <span class="title">Test</span>(<span class="params">[FromBody]<span class="built_in">string</span> username</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> ApiReturn&lt;<span class="built_in">string</span>&gt;.ResponseResult(username, StatusCodes.Fail);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="进一步优化"><a href="#进一步优化" class="headerlink" title="进一步优化"></a>进一步优化</h6><p>上面这样简化了对于返回的调用，但是这样每次还是需要手动输入ApiReturn，此时我们可以借助微软针对MVC的Controller的封装进一步得到一个思路，那就是定义一个基类的Controller，我们在Controller基类中，把常用的返回结果封装一些方法，这样在Controller的子类中呢就可以直接调用这些方法，而不需要关注如何去编写方法的返回类型了，</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ApiBaseContoller</span> : <span class="title">ControllerBase</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">ApiReturn</span>&lt;<span class="title">T</span>&gt; <span class="title">SuccessResult</span>&lt;<span class="title">T</span>&gt;(<span class="params">T data</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> ApiReturn&lt;T&gt;.SuccessResult(data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">ApiReturn</span>&lt;<span class="title">T</span>&gt; <span class="title">FailResult</span>&lt;<span class="title">T</span>&gt;(<span class="params"><span class="built_in">string</span> message = <span class="literal">null</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> ApiReturn&lt;T&gt;.FailResult(message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">ApiReturn</span>&lt;<span class="title">T</span>&gt; <span class="title">ErrorResult</span>&lt;<span class="title">T</span>&gt;(<span class="params"><span class="built_in">string</span> message = <span class="literal">null</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> ApiReturn&lt;T&gt;.ErrorResult(message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">ApiReturn</span>&lt;<span class="title">T</span>&gt; <span class="title">ResponseResult</span>&lt;<span class="title">T</span>&gt;(<span class="params">T data, StatusCodes code, <span class="built_in">string</span> message = <span class="literal">null</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> ApiReturn&lt;T&gt;.ResponseResult(data, code, message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>简单使用</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TestController</span> : <span class="title">ApiBaseContoller</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">HttpPost</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ApiReturn&lt;<span class="built_in">string</span>&gt; <span class="title">Test</span>(<span class="params">[FromBody]<span class="built_in">string</span> username</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> ResponseResult(username, StatusCodes.Fail);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还有一种做法时直接在ApiReturn<T>中借助implicit自动完成隐式转换，这样可以简化在成功时候的返回</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">implicit</span> <span class="keyword">operator</span> <span class="title">ApiReturn</span>&lt;<span class="title">T</span>&gt;(<span class="params">T <span class="keyword">value</span></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ApiReturn&lt;T&gt; &#123; Data =<span class="keyword">value</span>&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>简单使用</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ApiReturn&lt;<span class="built_in">string</span>&gt; <span class="title">Test</span>(<span class="params">[FromBody]<span class="built_in">string</span> username</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> username;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种做法在初始理解上面可能会有点麻烦。</p>
]]></content>
      <categories>
        <category>NetCore</category>
      </categories>
      <tags>
        <tag>WebApi</tag>
      </tags>
  </entry>
  <entry>
    <title>Session、Cookie、Token、Jwt</title>
    <url>/2022/10/27/Session%E3%80%81Cookie%E3%80%81Token%E3%80%81Jwt/</url>
    <content><![CDATA[<h4 id="什么是-Cookie"><a href="#什么是-Cookie" class="headerlink" title="什么是 Cookie"></a>什么是 Cookie</h4><ul>
<li>Http是无状态的：客户端的每一次请求都是独立的，服务端无法对当前访问者的身份信息进行确认，无法确认哪些请求来自同一个人，服务器与浏览器为了进行会话跟踪（知道是谁在访问我），就必须主动的去维护一个状态，这个状态用于告知服务端前后两个请求是否来自同一浏览器。而这个状态需要通过 cookie 或者 session 去实现。</li>
<li>cookie 存储在客户端： cookie 是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。</li>
<li>cookie 是不可跨域的： 每个 cookie 都会绑定单一的域名，无法在别的域名下获取使用，一级域名和二级域名之间是允许共享使用的（靠的是 domain）。</li>
</ul>
<span id="more"></span>

<h4 id="什么是-Session"><a href="#什么是-Session" class="headerlink" title="什么是 Session"></a>什么是 Session</h4><ul>
<li>session 是另一种记录服务器和客户端会话状态的机制</li>
<li>session 是基于 cookie 实现的，session 存储在服务器端，sessionId 会被存储到客户端的cookie 中</li>
<li>Session认证流程<ul>
<li>用户第一次访问服务器，服务器端生成Session</li>
<li>服务器将Session对应的SessionId写入cookie中</li>
<li>进行第二次访问的时候，客户端携带cookie进行访问，根据cookie中携带的Sessionid查找对应的Session，如果没有找到说明用户没有登录或者登录失效，如果找到 Session 证明用户已经登录可执行后面操作。</li>
</ul>
</li>
</ul>
<h4 id="Session与Cookie的区别"><a href="#Session与Cookie的区别" class="headerlink" title="Session与Cookie的区别"></a>Session与Cookie的区别</h4><ul>
<li>作用范围不同，Cookie 保存在客户端（浏览器），Session 保存在服务器端。</li>
<li>存取方式的不同，Cookie 只能保存 ASCII，Session 可以存任意数据类型，一般情况下我们可以在 Session 中保持一些常用变量信息，比如说 UserId 等。</li>
<li>有效期不同，Cookie 可设置为长时间保持，比如我们经常使用的默认登录功能，Session 一般失效时间较短，客户端关闭或者 Session 超时都会失效。</li>
<li>隐私策略不同，Cookie 存储在客户端，比较容易遭到不法获取，早期有人将用户的登录名和密码存储在 Cookie 中导致信息被窃取；Session 存储在服务端，安全性相对 Cookie 要好一些。</li>
<li>存储大小不同， 单个 Cookie 保存的数据不能超过 4K，Session 可存储数据远高于 Cookie。</li>
</ul>
<h4 id="Token"><a href="#Token" class="headerlink" title="Token"></a>Token</h4><p>Token的定义：Token是服务端生成的一串字符串，以作客户端进行请求的一个令牌，当第一次登录后，服务器生成一个Token便将此Token返回给客户端，客户端在此登录访问服务器需要带上token，验证用户的登录账号和密码的合法性。</p>
<ul>
<li>访问资源接口（API）时所需要的资源凭证</li>
<li>特点：<ul>
<li>服务端无状态化、可扩展性好</li>
<li>支持移动端设备</li>
<li>安全</li>
<li>支持跨程序调用</li>
</ul>
</li>
<li>基于 token 的用户认证是一种服务端无状态的认证方式，服务端不用存放 token 数据。用解析 token 的计算时间换取 session 的存储空间，从而减轻服务器的压力。</li>
</ul>
<h4 id="Token-和-Session-的区别"><a href="#Token-和-Session-的区别" class="headerlink" title="Token 和 Session 的区别"></a>Token 和 Session 的区别</h4><ul>
<li>Session 是一种记录服务器和客户端会话状态的机制，使服务端有状态化，可以记录会话信息。而 Token 是令牌，访问资源接口（API）时所需要的资源凭证。Token 使服务端无状态化，不会存储会话信息。</li>
<li>作为身份认证 Token 安全性比 Session 好，因为每一个请求都有签名还能防止监听以及重放攻击，而 Session 就必须依赖链路层来保障通讯安全了。如果你需要实现有状态的会话，仍然可以增加 Session 来在服务器端保存一些状态。</li>
</ul>
<h4 id="使用cookie需要注意的问题"><a href="#使用cookie需要注意的问题" class="headerlink" title="使用cookie需要注意的问题"></a>使用cookie需要注意的问题</h4><ul>
<li>因为存储在客户端，容易被客户端篡改，使用前需要验证合法性</li>
<li>不要存储敏感数据，比如用户密码，账户余额</li>
<li>使用 httpOnly 在一定程度上提高安全性</li>
<li>尽量减少 cookie 的体积，能存储的数据量不能超过 4kb</li>
<li>设置正确的 domain 和 path，减少数据传输</li>
<li>cookie 无法跨域</li>
<li>一个浏览器针对一个网站最多存 20 个Cookie，浏览器一般只允许存放 300 个Cookie</li>
<li>移动端对 cookie 的支持不是很好，而 session 需要基于 cookie 实现，所以移动端常用的是 token</li>
</ul>
<h4 id="使用Session需要注意的问题"><a href="#使用Session需要注意的问题" class="headerlink" title="使用Session需要注意的问题"></a>使用Session需要注意的问题</h4><ul>
<li>将 session 存储在服务器里面，当用户同时在线量比较多时，这些 session 会占据较多的内存，需要在服务端定期的去清理过期的 session</li>
<li>当网站采用集群部署的时候，会遇到多台 web 服务器之间如何做 session 共享的问题。因为 session 是由单个服务器创建的，但是处理用户请求的服务器不一定是那个创建 session 的服务器，那么该服务器就无法拿到之前已经放入到 session 中的登录凭证之类的信息了。</li>
<li>当多个应用要共享 session 时，除了以上问题，还会遇到跨域问题，因为不同的应用可能部署的主机不一样，需要在各个应用做好 cookie 跨域的处理。</li>
<li>sessionId 是存储在 cookie 中的，假如浏览器禁止 cookie 或不支持 cookie 怎么办？ 一般会把 sessionId 跟在 url 参数后面即重写 url，所以 session 不一定非得需要靠 cookie 实现</li>
</ul>
<h4 id="Session共享方案"><a href="#Session共享方案" class="headerlink" title="Session共享方案"></a>Session共享方案</h4><ul>
<li>session 复制<ul>
<li>任何一个服务器上的 session 发生改变（增删改），该节点会把这个 session 的所有内容序列化，然后广播给所有其它节点，不管其他服务器需不需要 session ，以此来保证 session 同步。</li>
</ul>
</li>
<li>session &#x2F;IP 绑定策略<ul>
<li>采用 Ngnix 中的 ip_hash 机制，将某个 ip的所有请求都定向到同一台服务器上，即将用户与服务器绑定。</li>
</ul>
</li>
<li>session 共享<ul>
<li>使用分布式缓存方案比如 Memcached 、Redis 来缓存 session，但是要求 Memcached 或 Redis 必须是集群</li>
<li>把 session 放到 Redis 中存储，虽然架构上变得复杂，并且需要多访问一次 Redis ，但是这种方案带来的好处也是很大的：<ul>
<li>实现了 session 共享；</li>
<li>可以水平扩展（增加 Redis 服务器）；</li>
<li>服务器重启 session 不丢失（不过也要注意 session 在 Redis 中的刷新&#x2F;失效机制）；</li>
<li>不仅可以跨服务器 session 共享，甚至可以跨平台（例如网页端和 APP 端）</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>NetCore自定义json序列化</title>
    <url>/2022/11/09/NetCore%E8%87%AA%E5%AE%9A%E4%B9%89json%E5%BA%8F%E5%88%97%E5%8C%96/</url>
    <content><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在进行项目开发的过程中，序列化与反序列化是会经常遇到的场景，在 <code>net core</code> 项目开发中，通常使用 <code>Newtonsoft.Json</code> 包中的进行序列化和反序列操作，这个包中的 <code>SerializeObject</code> (序列化)和 <code>DeserializeObject</code>（反序列化）能解决业务场景中90%以上的问题，但是开发过程中还是会遇到剩下的那20%的场景。下面对使用 <code>Newtonsoft.Json</code> 的自定义json序列化进行介绍。</p>
<span id="more"></span>

<h2 id="自定义Json序列化"><a href="#自定义Json序列化" class="headerlink" title="自定义Json序列化"></a>自定义Json序列化</h2><p>在介绍自定义序列化前，先对 <code>Newtonsoft.Json</code> 中的几个自带特性进行介绍</p>
<h3 id="特性介绍"><a href="#特性介绍" class="headerlink" title="特性介绍"></a>特性介绍</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[JsonIgnore]</span><br><span class="line">该特性可以忽略序列化某个实体类字段</span><br><span class="line"></span><br><span class="line">[JsonProperty(<span class="string">&quot;Font&quot;</span>)]</span><br><span class="line">用于设置序列化到json中的实际名称</span><br></pre></td></tr></table></figure>

<h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><p>在自定义序列的时候我们需要实现一个converter继承自 <code>Newtonsoft.Json</code> 中的 <code>JsonConvert</code> ，并实现其中的方法，实现方法前我们需要了解需要实现方法的作用</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">JsonConverter</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">JsonConverter</span>()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//是否开启自定义反序列化，值为true时，反序列化时会走ReadJson方法，值为false时，不走ReadJson方法，而是默认的反序列化</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">virtual</span> <span class="built_in">bool</span> CanRead &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//是否开启自定义序列化，值为true时，序列化时会走WriteJson方法，值为false时，不走WriteJson方法，而是默认的序列化</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">virtual</span> <span class="built_in">bool</span> CanWrite &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//能否对某类型进行序列化和反序列化，为true时，匹配该类型，值为false时，不匹配该类型</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="built_in">bool</span> <span class="title">CanConvert</span>(<span class="params">Type objectType</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//自定义反序列化方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="built_in">object</span> <span class="title">ReadJson</span>(<span class="params">JsonReader reader, Type objectType, <span class="built_in">object</span> existingValue, JsonSerializer serializer</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//自定义序列化</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">WriteJson</span>(<span class="params">JsonWriter writer, <span class="built_in">object</span> <span class="keyword">value</span>, JsonSerializer serializer</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>通过了解上述类中方法的作用，我们在自定义序列化的时候需要 <code>CanRead</code> 属性为true，且实现 <code>CanConvert()</code>判断指定类型，同时需要实现 <code>WriteJson()</code>方法作为实际自定义输出，下面通过两个简单的例子进行介绍实际使用</p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>首先交代一下使用的类</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Model</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Model</span>(<span class="params"><span class="built_in">int</span> id, <span class="built_in">string</span> name, <span class="built_in">int</span> age, DateTime createTime</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        CreateTime = createTime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> id &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> age &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> DateTime CreateTime &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>初始化一个类</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">Model model = <span class="keyword">new</span> Model(<span class="number">1</span>, <span class="string">&quot;tony&quot;</span>, <span class="number">22</span>, DateTime.Now);</span><br></pre></td></tr></table></figure>

<p>现在使用自带的序列化方法序列化结果如下</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;id&quot;</span><span class="punctuation">:</span><span class="number">1</span><span class="punctuation">,</span><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="string">&quot;tony&quot;</span><span class="punctuation">,</span><span class="attr">&quot;age&quot;</span><span class="punctuation">:</span><span class="number">22</span><span class="punctuation">,</span><span class="attr">&quot;CreateTime&quot;</span><span class="punctuation">:</span><span class="string">&quot;2022-11-09T14:40:04.1560759+08:00&quot;</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>可以看到此时 <code>CreateTime</code> 字段采用了默认的初始化,若此时我们需要将此字段序列化为时间戳的形式，我们需要如何处理呢？</p>
<p>实现一个converter继承自 <code>Newtonsoft.Json</code> 中的 <code>JsonConvert</code></p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">DateTimeConverter</span> : <span class="title">JsonConverter</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">bool</span> CanRead &#123; <span class="keyword">get</span> &#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">bool</span> CanWrite &#123; <span class="keyword">get</span> &#123; <span class="keyword">return</span> <span class="literal">true</span>; &#125; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">bool</span> <span class="title">CanConvert</span>(<span class="params">Type objectType</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> objectType == <span class="keyword">typeof</span>(DateTime);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">object</span> <span class="title">ReadJson</span>(<span class="params">JsonReader reader, Type objectType, <span class="built_in">object</span> existingValue, JsonSerializer serializer</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NotImplementedException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">WriteJson</span>(<span class="params">JsonWriter writer, <span class="built_in">object</span> <span class="keyword">value</span>, JsonSerializer serializer</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        TimeSpan ts = ((DateTime)<span class="keyword">value</span>) - <span class="keyword">new</span> DateTime(<span class="number">1970</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">string</span> convertTime = Convert.ToInt64(ts.TotalSeconds).ToString();</span><br><span class="line">        writer.WriteValue(convertTime);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另：此处仅介绍序列化内容，因此该类中 <code>ReadJson()</code> 方法未实现 </p>
<p>此时序列化时，将自定义的转换器作为参数传到序列化方法中</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Formatting.Indented用于格式化json</span></span><br><span class="line">JsonConvert.SerializeObject(model,Formatting.Indented,<span class="keyword">new</span> DateTimeConverter())</span><br></pre></td></tr></table></figure>

<p>此时输出结果为</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;tony&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;age&quot;</span><span class="punctuation">:</span> <span class="number">22</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;CreateTime&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1668004835&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>可以看到，此时DateTime类型的字段已经被序列化为时间戳形式</p>
<p>若此时我们需要将id作为序列化的key，其他的属性作为value，该如何处理呢？</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;1&quot;</span>: &#123;</span><br><span class="line">  <span class="string">&quot;name&quot;</span>: <span class="string">&quot;tony&quot;</span>,</span><br><span class="line">  <span class="string">&quot;age&quot;</span>: <span class="number">22</span>,</span><br><span class="line">  <span class="string">&quot;CreateTime&quot;</span>: <span class="string">&quot;1668004861&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外实现一个转换器</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">ModelConverter</span>:<span class="title">JsonConverter</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">bool</span> CanRead &#123; <span class="keyword">get</span> &#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">bool</span> CanWrite &#123; <span class="keyword">get</span> &#123; <span class="keyword">return</span> <span class="literal">true</span>; &#125; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">bool</span> <span class="title">CanConvert</span>(<span class="params">Type objectType</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> objectType == <span class="keyword">typeof</span>(Model);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">object</span> <span class="title">ReadJson</span>(<span class="params">JsonReader reader, Type objectType, <span class="built_in">object</span> existingValue, JsonSerializer serializer</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NotImplementedException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">WriteJson</span>(<span class="params">JsonWriter writer, <span class="built_in">object</span> <span class="keyword">value</span>, JsonSerializer serializer</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> model = <span class="keyword">value</span> <span class="keyword">as</span> Model;</span><br><span class="line">        <span class="keyword">if</span> (model == <span class="literal">null</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        writer.WriteStartObject();</span><br><span class="line">        writer.WritePropertyName(model.id.ToString());</span><br><span class="line">        <span class="comment">//此处时间仍然转化为时间戳的形式</span></span><br><span class="line">        writer.WriteRawValue(JsonConvert.SerializeObject(<span class="keyword">new</span> &#123; name=model.name,age=model.age,CreateTime=model.CreateTime&#125;, Formatting.Indented, <span class="keyword">new</span> DateTimeConverter()));</span><br><span class="line">        writer.WriteEndObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以使用特性的方式处理，在Model上加上特性,该类型在序列化的时候会将该转换器加入到可用转换器中</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[JsonConverter(typeof(ModelConverter))]</span><br></pre></td></tr></table></figure>

<p>也可以用上面的方式实现自定义转换器的调用</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">JsonConvert.SerializeObject(model,Formatting.Indented,<span class="keyword">new</span> ModelConverter())</span><br></pre></td></tr></table></figure>

<p>实际开发中，可根据实际业务场景去定义所需转换器</p>
]]></content>
      <categories>
        <category>NetCore</category>
      </categories>
      <tags>
        <tag>Json</tag>
      </tags>
  </entry>
  <entry>
    <title>xunit-单元测试</title>
    <url>/2022/10/27/xunit-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[<h3 id="使用xunit进行单元测试"><a href="#使用xunit进行单元测试" class="headerlink" title="使用xunit进行单元测试"></a>使用xunit进行单元测试</h3><h4 id="为什么要进行自动化测试？"><a href="#为什么要进行自动化测试？" class="headerlink" title="为什么要进行自动化测试？"></a>为什么要进行自动化测试？</h4><span id="more"></span>

<ul>
<li><p>手工测试的局限性</p>
<ul>
<li>手工测试不能覆盖所有代码路径。</li>
<li>基本的功能性测试用例在每一轮测试中都不能少。由于工作量往往较大，属于重复性的、非智力性的和非创造性，并要求准确细致，使用机器比人类更有优势。</li>
<li>许多死锁、资源冲突、多线程等有关的不正确 ，通过手工测试很难捕捉到。</li>
<li>系统压力、性能测试，需要模拟大数据或大并发用户等各种测试场景，很难通过手工测试执行。</li>
<li>系统可靠性测试，需要模拟系统长时间运行，以验证系统能否稳定运行，难以通过手工测试执行。</li>
<li>如果有大量（几千）的测试用例，须要在短时间内（1天）完成，手工测试几乎不可能做到。</li>
</ul>
</li>
<li><p>自动化测试的优点</p>
<ul>
<li>避免重复工作：对于功能已经完整和成熟的软件，每发布一个新的版本，其中大部分功能和界面都和上一个版本相似或完全相同，这部分功能特别适合于自动化测试，从而可以让测试达到测试每个特征的目的。</li>
<li>提高测试效率：DCC版本的发布周期往往比较短，也就是开发周期只有短短的几个月，而在测试期间是每天&#x2F;每2天都要发布一个版本供测试人员测试，一个系统的功能点有几千个上万个，人工测试是非常的耗时和繁琐，这样必然会使测试效率低下。</li>
<li>保证每次测试的一致性和可重复性：由于每次自动化测试运行的脚本是相同的，所以每次执行的测试具有一致性，人是很难做到的。由于自动化测试的一致性，很容易发现被测软件的任何改变。</li>
<li>更好的利用资源－－周未&#x2F;晚上。理想的自动化测试能够按计划完全自动的运行，在开发人员和测试人员不可能实行三班倒的情况下， 自动化测试可以胜任这个任务， 完全可以在周末和晚上执行测试。这样充分的利用了公司的资源，也避免了开发和测试之间的等待。</li>
<li>解决测试与开发之间的矛盾：通常在开发的末期，进入集成测试阶段，由于每发布一个版本的初期，测试系统的错误比较少，这时开发人员在等待测试人员测试出错误的时间。事实上在迭代周期很短的开发模式中，存在更多的矛盾，但自动化测试可以解决其中的主要矛盾。</li>
</ul>
</li>
</ul>
<h4 id="自动化测试的分类"><a href="#自动化测试的分类" class="headerlink" title="自动化测试的分类"></a>自动化测试的分类</h4><ul>
<li>Unit Test 单元测试， 它可以测试一个类，或者一个类的某个功能，它具有很好的深度，但是对整个应用来说它不具备很好的覆盖面。</li>
<li>Integration Test 集成测试，它没有单元测试那么细致，但是具有相对较好的测试覆盖面。例如它可以测试功能的组合，以及像数据库或文件系统这样的外部资源等。</li>
<li>Subcutaneous Test 皮下测试，这种测试作用于UI层的下面一层，这也意味着它对整个应用来说有很好的覆盖率，但是深度欠佳。那一个MVC结构的应用来说，它就是针对刚好在Controller下面一层的测试，对于Web service来说，它就是对节点下面那层的测试。</li>
<li>UI测试，它的测试覆盖面很广，直接从UI层面进行测试，但是深度欠佳。</li>
</ul>
<h4 id="测试的三个阶段AAA"><a href="#测试的三个阶段AAA" class="headerlink" title="测试的三个阶段AAA"></a>测试的三个阶段AAA</h4><ul>
<li>Arrange，这里做一些先决的设定。例如创建对象实例，数据，输入等等。</li>
<li>Act，在这里执行生产代码并返回结果。例如调用方法，或者设置属性（Properties）。</li>
<li>Assert，在这里检查结果。测试通过或者失败。</li>
</ul>
<h4 id="xunit进行单元测试——Assert"><a href="#xunit进行单元测试——Assert" class="headerlink" title="xunit进行单元测试——Assert"></a>xunit进行单元测试——Assert</h4><p>Assert：Assert基于代码的返回值、对象的最终状态、事件是否发生等情况来评估测试的结果。Assert的结果可能是Pass或者Fail。如果所有的asserts都pass了，那么整个测试就pass了；如果有任何assert fail了，那么测试就fail了。<br>xUnit提供了以下类型的Assert：</p>
<ul>
<li>boolean：True&#x2F;False</li>
<li>String：相等&#x2F;不等，是否为空，以..开始&#x2F;结束，是否包含子字符串，匹配正则表达式</li>
<li>数值型：相等&#x2F;不等，是否在某个范围内，浮点的精度</li>
<li>Collection：内容是否相等，是否包含某个元素，是否包含满足某种条件(predicate)的元素，是否所有的元素都满足某个assert</li>
<li>Raised events：Custom events，Framework events(例如：PropertyChanged)</li>
<li>Object Type：是否是某种类型，是否某种类型或继承与某种类型</li>
</ul>
<h5 id="boolean-Assert"><a href="#boolean-Assert" class="headerlink" title="boolean Assert"></a>boolean Assert</h5><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//判断是否为true</span></span><br><span class="line">Assert.Ture(<span class="built_in">bool</span> condition)</span><br><span class="line"><span class="comment">//判断是否为false</span></span><br><span class="line">Assert.False(<span class="built_in">bool</span> condition)</span><br></pre></td></tr></table></figure>

<h5 id="string-Assert"><a href="#string-Assert" class="headerlink" title="string Assert"></a>string Assert</h5><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//判断是否相等</span></span><br><span class="line">Assert.Equal(<span class="built_in">string</span> expected, <span class="built_in">string</span> actual)</span><br><span class="line"><span class="comment">//判断是否不等</span></span><br><span class="line">Assert.NotEqual(<span class="built_in">string</span> expected, <span class="built_in">string</span> actual)</span><br><span class="line"><span class="comment">//判断是否为空</span></span><br><span class="line">Assert.Null(<span class="built_in">string</span> expected)</span><br><span class="line">Assert.NotNull(<span class="built_in">string</span> expected)</span><br><span class="line"><span class="comment">//以..开始/结束</span></span><br><span class="line">Assert.StartsWith(<span class="built_in">string</span> expectedStartString, <span class="built_in">string</span> actualString)</span><br><span class="line">Assert.EndsWith(<span class="built_in">string</span> expectedStartString, <span class="built_in">string</span> actualString)</span><br><span class="line"><span class="comment">//是否包含某个字符串</span></span><br><span class="line">Assert.Contains(<span class="built_in">string</span> expectedSubstring, <span class="built_in">string</span> actualString)</span><br><span class="line"><span class="comment">//匹配正则表达式</span></span><br><span class="line">Assert.Matches(Regex expectedRegex, <span class="built_in">string</span> actualString)</span><br></pre></td></tr></table></figure>

<h5 id="数值-Assert"><a href="#数值-Assert" class="headerlink" title="数值 Assert"></a>数值 Assert</h5><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//相等/不等</span></span><br><span class="line">Assert.Equal&lt;T&gt;(T expected, T actual)</span><br><span class="line">Assert.NotEqual&lt;T&gt;(T expected, T actual)</span><br><span class="line"><span class="comment">//是否在某个范围内</span></span><br><span class="line">Assert.InRange&lt;T&gt;(T actual, T low, T high)</span><br><span class="line"><span class="comment">//浮点的精度</span></span><br><span class="line">Assert.Equal(<span class="built_in">double</span> expected, <span class="built_in">double</span> actual, <span class="built_in">int</span> precision)</span><br></pre></td></tr></table></figure>

<h5 id="Collection-Assert"><a href="#Collection-Assert" class="headerlink" title="Collection Assert"></a>Collection Assert</h5><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//是否包含某个元素</span></span><br><span class="line">Assert.Contains&lt;T&gt;(T expected, IEnumerable&lt;T&gt; collection)</span><br><span class="line"><span class="comment">//是否包含满足某种条件(predicate)的元素</span></span><br><span class="line">Assert.Contains&lt;T&gt;(IEnumerable&lt;T&gt; collection, Predicate&lt;T&gt; filter)</span><br><span class="line"><span class="comment">//是否所有的元素都满足某个assert</span></span><br><span class="line">Assert.All&lt;T&gt;(IEnumerable&lt;T&gt; collection, Action&lt;T&gt; action)</span><br></pre></td></tr></table></figure>

<h5 id="Object-Type-Assert"><a href="#Object-Type-Assert" class="headerlink" title="Object Type Assert"></a>Object Type Assert</h5><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//是否是某种类型</span></span><br><span class="line">Assert.IsType&lt;T&gt;(<span class="built_in">object</span> @object)</span><br><span class="line"><span class="comment">//是否某种类型或继承与某种类型</span></span><br><span class="line">Assert.IsAssignableFrom&lt;祖先类&gt;(xx):</span><br><span class="line"><span class="comment">//判断两个引用是否指向不同的实例 </span></span><br><span class="line">Assert.NotSame(a, b):</span><br></pre></td></tr></table></figure>

<h5 id="异常-Assert"><a href="#异常-Assert" class="headerlink" title="异常 Assert"></a>异常 Assert</h5><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Assert是否抛出了特定类型的异常.</span></span><br><span class="line">Assert.Throws&lt;ArgumentNullException&gt;(...)</span><br></pre></td></tr></table></figure>

<h5 id="Assert-Events-是否发生-Raised"><a href="#Assert-Events-是否发生-Raised" class="headerlink" title="Assert Events 是否发生(Raised)"></a>Assert Events 是否发生(Raised)</h5><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">Assert.Raises&lt;T&gt;()</span><br><span class="line"><span class="comment">//断定PropertyChanged的Event是否被触发了.</span></span><br><span class="line">Assert.PropertyChanged(..) </span><br></pre></td></tr></table></figure>

<h4 id="xunit进行单元测试——Attribute"><a href="#xunit进行单元测试——Attribute" class="headerlink" title="xunit进行单元测试——Attribute"></a>xunit进行单元测试——Attribute</h4><p>xunit中常用的框架属性</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>[fact]</td>
<td>标记测试方法，即类中的实际测试</td>
</tr>
<tr>
<td>[Trait]</td>
<td>在测试中设置任意元数据</td>
</tr>
<tr>
<td>[Fact(DisplayName &#x3D;”name”))]</td>
<td>在属性上设置 DisplayName 参数修改显示名称。</td>
</tr>
<tr>
<td>[Fact(Skip&#x3D;”reason”)]</td>
<td>在属性上设置 Skip 参数以暂时跳过测试。</td>
</tr>
<tr>
<td>[Theory]</td>
<td>当必须执行数据驱动的测试时，将使用此属性。在这种情况下，必须使用[理论]而不是[事实]属性</td>
</tr>
<tr>
<td>[InlineData]</td>
<td>此属性与 [Theory] 属性一起使用，以提供将对其执行参数化测试的数据子集。</td>
</tr>
<tr>
<td>[ClassData]</td>
<td>当传递给 [Theory] 测试的参数不是常量时，将使用此属性。</td>
</tr>
<tr>
<td>[MemberData]</td>
<td>测试多组参数</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>NetCore</category>
      </categories>
      <tags>
        <tag>测试</tag>
      </tags>
  </entry>
  <entry>
    <title>高并发下的数据库与缓存一致性问题</title>
    <url>/2022/10/27/%E9%AB%98%E5%B9%B6%E5%8F%91%E4%B8%8B%E7%9A%84%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8E%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>在互联网业务中，传统的直接访问数据库方式，主要是通过数据分片，一写多读的方式去抗住数据流量，但是随着数据量的激增，并且大多数都是读多写少的场景 ，仅仅依靠数据库查询，成本高，效率低，且稳定性远远不够。因此，在架构设计中，常采用增加缓存层来提高系统的响应能力，提升数据读写性能、减少数据库访问压力，从而提升业务的稳定性和访问体验。<br>引入缓存又带来了新的问题，那就是数据库与缓存一致性的问题，该问题不局限于语言，是个公共问题，尤其在高并发的情况下很容易出现该问题。</p>
<span id="more"></span>

<p>使用数据库缓存的场景一般可以分为读操作和写操作。</p>
<ul>
<li><strong>读操作</strong>：<ul>
<li>命中缓存(cache hit)：当客户端从缓存中读取到数据时，可以直接返回。</li>
<li>未命中缓存(cache miss)：当读取的数据不在缓存时，需要从数据库中读取数据并写入缓存。</li>
<li><strong>缓存的命中率</strong> &#x3D; 命中缓存请求个数&#x2F;总缓存访问请求个数 &#x3D; hit &#x2F; (hit+miss)，缓存的命中率是衡量缓存效果的重要指标，命中率越大，对后端数据库的压力越小。</li>
</ul>
</li>
<li><strong>写操作</strong>：<ul>
<li>缓存与数据库中的数据都需要被修改，因为要涉及缓存和数据库两个点的数据修改，且无法满足原子性，需要重点考虑数据一致性的问题，这也是数据库缓存使用的难点和重点。</li>
</ul>
</li>
</ul>
<h3 id="常见的解决方案"><a href="#常见的解决方案" class="headerlink" title="常见的解决方案"></a>常见的解决方案</h3><h4 id="先更新缓存，再更新数据库"><a href="#先更新缓存，再更新数据库" class="headerlink" title="先更新缓存，再更新数据库"></a>先更新缓存，再更新数据库</h4><ul>
<li>我们先来分析一下此种方案的问题<ul>
<li>初始缓存为0，数据库为0，A更新缓存为1</li>
<li>A更新数据库失败，此时数据库中数据为0，缓存中数据为0</li>
<li>出现脏数据情况</li>
</ul>
</li>
</ul>
<p><strong>异步回写</strong>：在处理写请求的时候，先只更新缓存，对于数据库的更新是使用批量异步更新的方式去处理的，这种方式，由于前面的更新操作只发生在缓存中，因此对于缓存的高可用要求比较高，但由于读写操作都在缓存中处理，大大提升了响应速度</p>
<ul>
<li>使用场景<br>比较适用于写入较多的极端场景，例如：电商秒杀系统</li>
</ul>
<h4 id="先更新数据库，再更新缓存"><a href="#先更新数据库，再更新缓存" class="headerlink" title="先更新数据库，再更新缓存"></a>先更新数据库，再更新缓存</h4><ul>
<li>分析一下此种方案的问题<ul>
<li>初始缓存为0，数据库为0</li>
<li>A请求更新数据，更新数据库中数据为1</li>
<li>B请求更新数据，更新数据库中数据为2，此时数据库中数据为2</li>
<li>B更新缓存中数据为2，A由于网络延迟此时才更新缓存中的数据，更新缓存中数据为1</li>
<li>出现数据库与缓存不一致情况</li>
</ul>
</li>
<li>更新缓存失败也会造成数据库与缓存不一致情况出现</li>
</ul>
<p><strong>直写模式</strong>：这种模式优点在于读请求过程十分简单，不需要进行数据库查询操作，不管是先更新数据库，再更新缓存，还是先更新缓存再更新数据库，都会由于线程竞争原因出现数据库与缓存不一致的情况。</p>
<p><strong>解决方案</strong>：可以将数据库更新与缓存的更新放在同一个事务中处理，线程竞争导致的不一致情况通过分布式锁解决，保证对缓存和数据库的操作仅能由同一个线程完成。对于没有拿到锁的线程，一是通过锁的timeout时间进行控制，二是将请求暂存在消息队列中顺序消费。</p>
<ul>
<li>使用场景<br>适合写操作较多，并且对一致性要求较高的场景</li>
</ul>
<p>上述两种方案，都是去更新缓存，主要是为了写操作较多的场景，针对于读操作较多的场景，可以使用删除缓存的形式去处理，这样处理的好处</p>
<ul>
<li>性能方面：假设缓存不是从数据库中读取出后就直接写进去的，而是需要复杂的计算后才能得出需要写入缓存的结果，此时每次更新数据的操作都去更新缓存在不需要读取该缓存的时候是不必要的，我们可以删除缓存，在读操作的时候再进行缓存的写入，这样可以大大提高性能。</li>
<li><code>分析：</code>删除与更新在实际上的区别就是一次cache  miss</li>
</ul>
<h3 id="先删除缓存，再写入数据库"><a href="#先删除缓存，再写入数据库" class="headerlink" title="先删除缓存，再写入数据库"></a>先删除缓存，再写入数据库</h3><ul>
<li>分析一下此种方案的问题<ul>
<li>初始数据库中为0，缓存中为0</li>
<li>A删除缓存，在A还未更新数据库时B请求读数据，缓存中无数据，从数据库中读取0，并写入缓存中</li>
<li>A更新数据库为1，此时缓存中为0，数据库中为1，出现数据库与缓存不一致情况</li>
</ul>
</li>
</ul>
<p><strong>解决方案</strong>：使用延时删除策略，即更新数据库后再对缓存进行删除操作，延时时间根据读操作并写缓存的耗时决定</p>
<p><code>疑问</code>：延时双删与先更新数据库后删除缓存的区别以及优势在哪</p>
<p>个人理解：延时双删由于先删除缓存中的数据，可以保证在删除缓存与更新数据库的过程中一定获取的为最新的数据。同时对于先更新数据库再更新缓存中必出现的短暂缓存不一致情况，此时延时双删这阶段出现缓存不一致概率会有所降低。</p>
<p>但是由于我们讨论的场景为高并发的场景下，在读操作比较多的时候，在删除缓存与更新数据库间出现数据查询的概率还是很高的，因此此时延时双删的方案的问题就又变回了先更新再删除缓存的问题。同时也引入了延时的时间确定性麻烦，不建议盲目使用延时双删策略</p>
<h3 id="先更新数据库，再删除缓存"><a href="#先更新数据库，再删除缓存" class="headerlink" title="先更新数据库，再删除缓存"></a>先更新数据库，再删除缓存</h3><ul>
<li>分析一下此种方案的问题<ul>
<li>初始数据库中为0，缓存中为0</li>
<li>A更新数据库为1，此时B查询缓存为0，但数据库为1，出现数据库与缓存不一致情况</li>
<li>A删除缓存失败，也会出现不一致情况</li>
</ul>
</li>
</ul>
<p>此方案中更新数据库与删除缓存的短暂数据库不一致情况可忽略，主要处理删除缓存失败的情况</p>
<p><strong>解决方案</strong>：主要是针对上述删除缓存失败的情况，为此使用补偿机制</p>
<ul>
<li>添加删除重试机制<br>使用消息队列的形式去处理。将删除失败的缓存对应的key放入消息队列中，在对应的消费者中获取删除失败的key，异步重试删除。这种方式对代码有侵入性</li>
<li>基于数据库日志（MySQL binlog）增量解析、订阅和消费</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>从上述分析来看，不管哪种方式可能都存在一定的不一致情况出现，需要针对不同的场景进行不同的设计，同时在缓存的处理上面可以使用分布式锁的机制去处理，也可以避免缓存不一致情况，但是此种方式会影响系统的吞吐量，在使用缓存的时候要使用过期时间去处理。</p>
<p>在读多写少的场景中，建议使用先更新数据库，再删除缓存的方式进行处理，再写多且对数据一致性要求比较高的场景中，可以使用先更新数据库，再更新缓存的方式处理，面对一些极端写场景，可以使用先更新缓存，然后异步写入数据库的方式处理。</p>
]]></content>
      <categories>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>一致性问题</tag>
      </tags>
  </entry>
</search>
