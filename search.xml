<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Leetcode-76-最小覆盖子串</title>
    <url>/2022/10/21/Leetcode-76-%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%AD%90%E4%B8%B2/</url>
    <content><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个字符串<code>s</code>、一个字符串<code>t</code>。返回<code>s</code>中涵盖<code>t</code>所有字符的最小子串。如果<code>s</code>中不存在涵盖<code>t</code>所有字符的子串，则返回空字符串<code>&quot;&quot;</code>。</p>
<span id="more"></span>

<p>注意：</p>
<p>对<code>t</code>中重复字符，我们寻找的子字符串中该字符数量必须不少于<code>t</code>中该字符数量。<br>如果<code>s</code>中存在这样的子串，我们保证它是唯一的答案。</p>
<h4 id="示例-1："><a href="#示例-1：" class="headerlink" title="示例 1："></a>示例 1：</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">输入：s = <span class="string">&quot;ADOBECODEBANC&quot;</span>, t = <span class="string">&quot;ABC&quot;</span></span><br><span class="line">输出：<span class="string">&quot;BANC&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="示例-2："><a href="#示例-2：" class="headerlink" title="示例 2："></a>示例 2：</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">输入：s = <span class="string">&quot;a&quot;</span>, t = <span class="string">&quot;a&quot;</span></span><br><span class="line">输出：<span class="string">&quot;a&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="示例-3"><a href="#示例-3" class="headerlink" title="示例 3:"></a>示例 3:</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">输入: s = <span class="string">&quot;a&quot;</span>, t = <span class="string">&quot;aa&quot;</span></span><br><span class="line">输出: <span class="string">&quot;&quot;</span></span><br><span class="line">解释: t 中两个字符 <span class="string">&#x27;a&#x27;</span> 均应包含在 s 的子串中，</span><br><span class="line">因此没有符合条件的子字符串，返回空字符串。</span><br></pre></td></tr></table></figure>

<ul>
<li>提示<br>1 &lt;&#x3D; s.length, t.length &lt;&#x3D; 105<br>s 和 t 由英文字母组成</li>
</ul>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>此题采用滑动窗口思想</p>
<ul>
<li>定义start,end&#x3D;0，为我们初始的滑动窗口</li>
<li>开始循环遍历整个数组元素，判断当前end指针是否超过整个数组的长度，是退出循环，否则执行第3步</li>
<li>然后end指针开始向右移动一个长度，并更新窗口内的区间数据</li>
<li>当窗口区间的数据满足我们的要求时，右指针end就保持不变，左指针start开始移动，直到移动到一个不满足要求的区间时，start不再移动位置</li>
<li>执行第2步</li>
</ul>
<p>此题的重点在于如何判断数据满足条件，即<code>s</code>的字串涵盖<code>t</code>所有字符<br>此处采用的是定义一个长度为128的数组用于存放字符出现的次数，此处也可优化，根据提示由英文字母组成，可简化数组长度<br>    - 先将目标字符串的字符初始到数组中<br>    - 遍历s，即滑动窗口并更新s数组中的元素<br>    - 当t中元素不为0时，判断s中元素是否大于t中元素值</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">string</span> <span class="title">MinWindow</span>(<span class="params"><span class="built_in">string</span> s, <span class="built_in">string</span> t</span>)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span>[] sArray = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">128</span>];</span><br><span class="line">    <span class="built_in">int</span>[] tArray = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">128</span>];</span><br><span class="line">    <span class="built_in">string</span> result = <span class="built_in">string</span>.Empty;</span><br><span class="line">    <span class="built_in">int</span> start = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">int</span> end = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; t.Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        tArray[t[i]] += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (end &lt; s.Length)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//移动左指针</span></span><br><span class="line">        sArray[s[end++]] += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (EqualsArray(sArray, tArray))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//更新result值</span></span><br><span class="line">            <span class="keyword">if</span> (result == <span class="built_in">string</span>.Empty)</span><br><span class="line">            &#123;</span><br><span class="line">                result = s.Substring(start, end - start);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                result = end - start &lt; result.Length ? s.Substring(start, end - start) : result;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//移动右指针</span></span><br><span class="line">            sArray[s[start++]] -= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//此函数用于判断此时s的字串是否包含t中所有元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">EqualsArray</span>(<span class="params"><span class="built_in">int</span>[] sArray, <span class="built_in">int</span>[] tArray</span>)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; tArray.Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (tArray[i] != <span class="number">0</span> &amp;&amp; tArray[i] &gt; sArray[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-1953-你可以工作的最大周数</title>
    <url>/2022/10/19/Leetcode-1953-%E4%BD%A0%E5%8F%AF%E4%BB%A5%E5%B7%A5%E4%BD%9C%E7%9A%84%E6%9C%80%E5%A4%A7%E5%91%A8%E6%95%B0/</url>
    <content><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你<code>n</code>个项目，编号从<code>0</code>到<code>n - 1</code>。同时给你一个整数数组<code>milestones</code>，其中每个<code>milestones[i]</code>表示第<code>i</code>个项目中的阶段任务数量。</p>
<span id="more"></span>
<p>你可以按下面两个规则参与项目中的工作：</p>
<p>每周，你将会完成<strong>某一个</strong>项目中的<strong>恰好一个</strong>阶段任务。你每周都<strong>必须</strong>工作。<br>在<strong>连续的</strong>两周中，你<strong>不能</strong>参与并完成同一个项目中的两个阶段任务。<br>一旦所有项目中的全部阶段任务都完成，或者仅剩余一个阶段任务都会导致你违反上面的规则，那么你将<strong>停止工作</strong>。注意，由于这些条件的限制，你可能无法完成所有阶段任务。</p>
<p>返回在不违反上面规则的情况下你<strong>最多</strong>能工作多少周。</p>
<h4 id="示例-1："><a href="#示例-1：" class="headerlink" title="示例 1："></a>示例 1：</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">输入：milestones = [1,2,3]</span><br><span class="line">输出：6</span><br><span class="line">解释：一种可能的情形是：</span><br><span class="line">​​​​- 第 1 周，你参与并完成项目 0 中的一个阶段任务。</span><br><span class="line">- 第 2 周，你参与并完成项目 2 中的一个阶段任务。</span><br><span class="line">- 第 3 周，你参与并完成项目 1 中的一个阶段任务。</span><br><span class="line">- 第 4 周，你参与并完成项目 2 中的一个阶段任务。</span><br><span class="line">- 第 5 周，你参与并完成项目 1 中的一个阶段任务。</span><br><span class="line">- 第 6 周，你参与并完成项目 2 中的一个阶段任务。</span><br><span class="line">总周数是 6 。</span><br></pre></td></tr></table></figure>

<h4 id="示例-2："><a href="#示例-2：" class="headerlink" title="示例 2："></a>示例 2：</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">输入：milestones = [5,2,1]</span><br><span class="line">输出：7</span><br><span class="line">解释：一种可能的情形是：</span><br><span class="line">- 第 1 周，你参与并完成项目 0 中的一个阶段任务。</span><br><span class="line">- 第 2 周，你参与并完成项目 1 中的一个阶段任务。</span><br><span class="line">- 第 3 周，你参与并完成项目 0 中的一个阶段任务。</span><br><span class="line">- 第 4 周，你参与并完成项目 1 中的一个阶段任务。</span><br><span class="line">- 第 5 周，你参与并完成项目 0 中的一个阶段任务。</span><br><span class="line">- 第 6 周，你参与并完成项目 2 中的一个阶段任务。</span><br><span class="line">- 第 7 周，你参与并完成项目 0 中的一个阶段任务。</span><br><span class="line">总周数是 7 。</span><br><span class="line">注意，你不能在第 8 周参与完成项目 0 中的最后一个阶段任务，因为这会违反规则。</span><br><span class="line">因此，项目 0 中会有一个阶段任务维持未完成状态。</span><br></pre></td></tr></table></figure>

<ul>
<li>提示<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">n == milestones.length</span><br><span class="line">1 &lt;= n &lt;= 105</span><br><span class="line">1 &lt;= milestones[i] &lt;= 109</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>本题采用贪心法的思路去处理，我们处理花费时长最多的项目，我们再处理该项目的时候，中间会插入其他项目</p>
<ul>
<li>若此时其他项目的总花费时间小于该项目时间，则最终工作时间为（其他项目时间总和*2）+1</li>
<li>若此时其他项目的总花费时间大于该项目时间，则一定可以穿插完成所有项目，即最终工作时间为所有项目时间总和</li>
</ul>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">long</span> <span class="title">NumberOfWeeks</span>(<span class="params"><span class="built_in">int</span>[] milestones</span>)</span> </span><br><span class="line">&#123;</span><br><span class="line">    Array.Sort(milestones);</span><br><span class="line">    <span class="built_in">long</span> temp = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">int</span> maxNum = milestones[milestones.Length - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; milestones.Length<span class="number">-1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        temp += milestones[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxNum &gt; temp ? (<span class="number">2</span>*temp+<span class="number">1</span>) : maxNum+temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-902-最大为N的数字组合</title>
    <url>/2022/10/18/Leetcode-902-%E6%9C%80%E5%A4%A7%E4%B8%BAN%E7%9A%84%E6%95%B0%E5%AD%97%E7%BB%84%E5%90%88/</url>
    <content><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个按<strong>非递减顺序</strong>排列的数字数组<code>digits</code>。你可以用任意次数<code>digits[i]</code>来写的数字。例如，如果<code>digits</code>&#x3D;<code>[&#39;1&#39;,&#39;3&#39;,&#39;5&#39;]</code>，我们可以写数字，如<code>&#39;13&#39;</code>,<code>&#39;551&#39;</code>, 和<code>&#39;1351315&#39;</code>。</p>
<p>返回 可以生成的小于或等于给定整数<code>n</code>的正整数的个数 。</p>
<span id="more"></span>

<h4 id="示例-1："><a href="#示例-1：" class="headerlink" title="示例 1："></a>示例 1：</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">输入：digits = [<span class="string">&quot;1&quot;</span>,<span class="string">&quot;3&quot;</span>,<span class="string">&quot;5&quot;</span>,<span class="string">&quot;7&quot;</span>], n = 100</span><br><span class="line">输出：20</span><br><span class="line">解释：</span><br><span class="line">可写出的 20 个数字是：</span><br><span class="line">1, 3, 5, 7, 11, 13, 15, 17, 31, 33, 35, 37, 51, 53, 55, 57, 71, 73, 75, 77.</span><br></pre></td></tr></table></figure>

<h4 id="示例-2："><a href="#示例-2：" class="headerlink" title="示例 2："></a>示例 2：</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">输入：digits = [<span class="string">&quot;1&quot;</span>,<span class="string">&quot;4&quot;</span>,<span class="string">&quot;9&quot;</span>], n = 1000000000</span><br><span class="line">输出：29523</span><br><span class="line">解释：</span><br><span class="line">我们可以写 3 个一位数字，9 个两位数字，27 个三位数字，</span><br><span class="line">81 个四位数字，243 个五位数字，729 个六位数字，</span><br><span class="line">2187 个七位数字，6561 个八位数字和 19683 个九位数字。</span><br><span class="line">总共，可以使用D中的数字写出 29523 个整数。</span><br></pre></td></tr></table></figure>

<h4 id="示例-2：-1"><a href="#示例-2：-1" class="headerlink" title="示例 2："></a>示例 2：</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">输入：digits = [<span class="string">&quot;7&quot;</span>], n = 8</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>

<ul>
<li>提示<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1 &lt;= digits.length &lt;= 9</span><br><span class="line">digits[i].length == 1</span><br><span class="line">digits[i] 是从 <span class="string">&#x27;1&#x27;</span> 到 <span class="string">&#x27;9&#x27;</span> 的数</span><br><span class="line">digits 中的所有值都 不同 </span><br><span class="line">digits 按 非递减顺序 排列</span><br><span class="line">1 &lt;= n &lt;= 109</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>根据题目意思，我们将问题拆分为两个部分</p>
<ul>
<li><p>当构成的数位数小于目标数数位的时候，个数为digits.Length^Length（构成数数位），此时构成的数显然都比目标数要小</p>
<ul>
<li>例如示例2中，构成三位数字的个数为<code>3^3=27</code>,构成四位数字的个数为<code>3^4=81</code></li>
</ul>
</li>
<li><p>当构成的数位数等于目标数数位的时候，我们从前向后遍历目标数，并于digits中的数进行比较</p>
<ul>
<li>若digits中的数比遍历的数字小，使用临时变量<code>temp</code>存储数量<ul>
<li>此时使用这些数为开头的数都比目标数小，个数为temp*(digits.Length^(位数-1))</li>
</ul>
</li>
<li>若digits中的数和遍历的数字相等时，继续向后遍历，此时注意，若digits中的数都比遍历数字大的时候，停止遍历</li>
<li>例如  digits &#x3D; [“5”，”4” , “3”, “2”],  n &#x3D; 4167 时，比4小的数有两个，则有2 * 4^3&#x3D;2 * 64&#x3D;128,比1小的数没有，此时停止遍历。</li>
<li>遍历到最末尾的时候，若还存在和遍历数字相等的数，需要将结果+1</li>
</ul>
</li>
</ul>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">AtMostNGivenDigitSet</span>(<span class="params"><span class="built_in">string</span>[] digits, <span class="built_in">int</span> n</span>)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">int</span> tempAdd = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">string</span> target = n.ToString();</span><br><span class="line">    <span class="built_in">int</span> length = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">int</span>[] digitsTemp = <span class="keyword">new</span> <span class="built_in">int</span>[digits.Length];</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; digits.Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        digitsTemp[i] = <span class="built_in">int</span>.Parse(digits[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//当构成的数位数小于目标数数位的时候</span></span><br><span class="line">    <span class="keyword">while</span> (target.Length &gt; length) </span><br><span class="line">    &#123;</span><br><span class="line">        result += (<span class="built_in">int</span>)Math.Pow(digits.Length, length);</span><br><span class="line">        length++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//当构成的数位数等于目标数数位的时候</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; target.Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> temp = <span class="number">0</span>;</span><br><span class="line">        tempAdd = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">int</span> targetNum = <span class="built_in">int</span>.Parse(target[i].ToString());</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> j = <span class="number">0</span>; j &lt; digitsTemp.Length; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//若digits中的数比遍历的数字小，使用临时变量`temp`存储数量</span></span><br><span class="line">            <span class="keyword">if</span> (targetNum &gt; digitsTemp[j]) </span><br><span class="line">            &#123;</span><br><span class="line">                temp++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//若digits中的数和遍历的数字相等时，继续遍历</span></span><br><span class="line">            <span class="keyword">if</span> (targetNum == digitsTemp[j]) </span><br><span class="line">            &#123;</span><br><span class="line">                tempAdd++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        result += temp*(<span class="built_in">int</span>)Math.Pow(digits.Length, length - i - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//若digits中的数都比遍历数字大的时候，停止遍历</span></span><br><span class="line">        <span class="keyword">if</span> (tempAdd == <span class="number">0</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;                </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//遍历到最末尾的时候，若还存在和遍历数字相等的数，需要将结果，即加上tempAdd,此时tempAdd为1</span></span><br><span class="line">    <span class="keyword">return</span> result+tempAdd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-1441-用栈操作构建数组</title>
    <url>/2022/10/17/Leetcode-1441-%E7%94%A8%E6%A0%88%E6%93%8D%E4%BD%9C%E6%9E%84%E5%BB%BA%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个数组<code>target</code>和一个整数<code>n</code>。每次迭代，需要从 <code>list = &#123; 1 , 2 , 3 ..., n &#125;</code>中依次读取一个数字。</p>
<span id="more"></span>

<p>请使用下述操作来构建目标数组<code>target</code>：</p>
<ul>
<li><code>&quot;Push&quot;</code>：从<code>list</code>中读取一个新元素， 并将其推入数组中。</li>
<li><code>&quot;Pop&quot;</code>：删除数组中的最后一个元素。</li>
<li>如果目标数组构建完成，就停止读取更多元素。</li>
</ul>
<p>题目数据保证目标数组严格递增，并且只包含<code>1</code>到<code>n</code>之间的数字。</p>
<p>请返回构建目标数组所用的操作序列。如果存在多个可行方案，返回任一即可。</p>
<h4 id="示例-1："><a href="#示例-1：" class="headerlink" title="示例 1："></a>示例 1：</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">输入：target = [1,3], n = 3</span><br><span class="line">输出：[<span class="string">&quot;Push&quot;</span>,<span class="string">&quot;Push&quot;</span>,<span class="string">&quot;Pop&quot;</span>,<span class="string">&quot;Push&quot;</span>]</span><br><span class="line">解释： </span><br><span class="line">读取 1 并自动推入数组 -&gt; [1]</span><br><span class="line">读取 2 并自动推入数组，然后删除它 -&gt; [1]</span><br><span class="line">读取 3 并自动推入数组 -&gt; [1,3]</span><br></pre></td></tr></table></figure>

<h4 id="示例-2："><a href="#示例-2：" class="headerlink" title="示例 2："></a>示例 2：</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">输入：target = [1,2,3], n = 3</span><br><span class="line">输出：[<span class="string">&quot;Push&quot;</span>,<span class="string">&quot;Push&quot;</span>,<span class="string">&quot;Push&quot;</span>]</span><br></pre></td></tr></table></figure>

<h4 id="示例-3："><a href="#示例-3：" class="headerlink" title="示例 3："></a>示例 3：</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">输入：target = [1,2], n = 4</span><br><span class="line">输出：[<span class="string">&quot;Push&quot;</span>,<span class="string">&quot;Push&quot;</span>]</span><br><span class="line">解释：只需要读取前 2 个数字就可以停止。</span><br></pre></td></tr></table></figure>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>题目中给出的数组是严格递增的，因此我们可以遍历<code>target</code>，同时维护一个<code>temp</code>，从<code>1</code>开始</p>
<ul>
<li>若<code>target</code>中的数不等于<code>temp</code>时<ul>
<li>添加[“Push”, “Pop”]</li>
</ul>
</li>
<li>若<code>target</code>中的数不等于<code>temp</code>时<ul>
<li>添加[“Push”]</li>
</ul>
</li>
</ul>
<p>遍历完成即数组构建完成</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> IList&lt;<span class="built_in">string</span>&gt; <span class="title">BuildArray</span>(<span class="params"><span class="built_in">int</span>[] target, <span class="built_in">int</span> n</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> temp = <span class="number">1</span>;</span><br><span class="line">    List&lt;<span class="built_in">string</span>&gt; result = <span class="keyword">new</span> List&lt;<span class="built_in">string</span>&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; target.Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (target[i] != temp) </span><br><span class="line">        &#123;</span><br><span class="line">            result.Add(<span class="string">&quot;Push&quot;</span>);</span><br><span class="line">            result.Add(<span class="string">&quot;Pop&quot;</span>);</span><br><span class="line">            temp++;</span><br><span class="line">        &#125;</span><br><span class="line">        result.Add(<span class="string">&quot;Push&quot;</span>);</span><br><span class="line">        temp++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-904-水果成篮</title>
    <url>/2022/10/17/Leetcode-904-%E6%B0%B4%E6%9E%9C%E6%88%90%E7%AF%AE/</url>
    <content><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>你正在探访一家农场，农场从左到右种植了一排果树。这些树用一个整数数组<code>fruits</code>表示，其中<code>fruits[i]</code>是第<code>i</code>棵树上的水果 种类 。</p>
<span id="more"></span>

<p>你想要尽可能多地收集水果。然而，农场的主人设定了一些严格的规矩，你必须按照要求采摘水果：</p>
<ul>
<li>你只有<code>两个</code>篮子，并且每个篮子只能装 单一类型 的水果。每个篮子能够装的水果总量没有限制。</li>
<li>你可以选择任意一棵树开始采摘，你必须从 每棵 树（包括开始采摘的树）上 恰好摘一个水果 。采摘的水果应当符合篮子中的水果类型。每采摘一次，你将会向右移动到下一棵树，并继续采摘。</li>
<li>一旦你走到某棵树前，但水果不符合篮子的水果类型，那么就必须停止采摘。</li>
</ul>
<p>给你一个整数数组<code>fruits</code>，返回你可以收集的水果的<code>最大</code>数目。</p>
<h4 id="示例-1："><a href="#示例-1：" class="headerlink" title="示例 1："></a>示例 1：</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">输入：fruits = [1,2,1]</span><br><span class="line">输出：3</span><br><span class="line">解释：可以采摘全部 3 棵树。</span><br></pre></td></tr></table></figure>

<h4 id="示例-2："><a href="#示例-2：" class="headerlink" title="示例 2："></a>示例 2：</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">输入：fruits = [0,1,2,2]</span><br><span class="line">输出：3</span><br><span class="line">解释：可以采摘 [1,2,2] 这三棵树。</span><br><span class="line">如果从第一棵树开始采摘，则只能采摘 [0,1] 这两棵树。</span><br></pre></td></tr></table></figure>

<h4 id="示例-3："><a href="#示例-3：" class="headerlink" title="示例 3："></a>示例 3：</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">输入：fruits = [1,2,3,2,2]</span><br><span class="line">输出：4</span><br><span class="line">解释：可以采摘 [2,3,2,2] 这四棵树。</span><br><span class="line">如果从第一棵树开始采摘，则只能采摘 [1,2] 这两棵树。</span><br></pre></td></tr></table></figure>

<h4 id="示例-4："><a href="#示例-4：" class="headerlink" title="示例 4："></a>示例 4：</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">输入：fruits = [3,3,3,1,2,1,1,2,3,3,4]</span><br><span class="line">输出：5</span><br><span class="line">解释：可以采摘 [1,2,1,1,2] 这五棵树。</span><br></pre></td></tr></table></figure>

<ul>
<li>提示<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1 &lt;= fruits.length &lt;= 105</span><br><span class="line">0 &lt;= fruits[i] &lt; fruits.length</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>此题采用滑动窗口算法的思路</p>
<ul>
<li>定义start,end&#x3D;0，为我们初始的滑动窗口</li>
<li>开始循环遍历整个数组元素，判断当前end指针是否超过整个数组的长度，是退出循环，否则执行第3步</li>
<li>然后end指针开始向右移动一个长度，并更新窗口内的区间数据</li>
<li>当窗口区间的数据不满足我们的要求时，右指针end就保持不变，左指针start开始移动，直到移动到一个满足要求的区间时，start不再移动位置</li>
<li>执行第2步</li>
</ul>
<p><code>例</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fruits = [3,3,3,1,2,1,1,2,3,3,4]</span><br><span class="line">end 移动 窗口元素为[3]，满足仅有两个元素的要求</span><br><span class="line">end 移动 窗口元素为[3,3]，满足仅有两个元素的要求</span><br><span class="line">end 移动 窗口元素为[3,3,3]，满足仅有两个元素的要求</span><br><span class="line">end 移动 窗口元素为[3,3,3,1]，满足仅有两个元素的要求     result=4</span><br><span class="line">end 移动 窗口元素为[3,3,3,1,2]，不满足仅有两个元素的要求 </span><br><span class="line">start 移动 窗口元素为[3,3,1,2]，不满足仅有两个元素的要求</span><br><span class="line">start 移动 窗口元素为[3,1,2]，不满足仅有两个元素的要求</span><br><span class="line">start 移动 窗口元素为[1,2]，满足仅有两个元素的要求</span><br><span class="line">end 移动 窗口元素为[1,2,1]，满足仅有两个元素的要求</span><br><span class="line">end 移动 窗口元素为[1,2,1,1]，满足仅有两个元素的要求</span><br><span class="line">end 移动 窗口元素为[1,2,1,1,2]，满足仅有两个元素的要求      result=5</span><br><span class="line">end 移动 窗口元素为[1,2,1,1,2,3]，不满足仅有两个元素的要求</span><br><span class="line">start 移动 窗口元素为[2,1,1,2,3]，不满足仅有两个元素的要求</span><br><span class="line">start 移动 窗口元素为[1,1,2,3]，不满足仅有两个元素的要求</span><br><span class="line">start 移动 窗口元素为[1,2,3]，不满足仅有两个元素的要求</span><br><span class="line">start 移动 窗口元素为[2,3]，满足仅有两个元素的要求</span><br><span class="line">end 移动 窗口元素为[2,3,3]，满足仅有两个元素的要求</span><br><span class="line">end 移动 窗口元素为[2,3,3,4]，不满足仅有两个元素的要求</span><br><span class="line">start 移动 窗口元素为[3,3,4]，满足仅有两个元素的要求</span><br><span class="line">结束</span><br></pre></td></tr></table></figure>

<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">TotalFruit</span>(<span class="params"><span class="built_in">int</span>[] fruits</span>)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> start = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">int</span> end = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">int</span> result = <span class="number">0</span>;</span><br><span class="line">    Dictionary&lt;<span class="built_in">int</span>, <span class="built_in">int</span>&gt; pairs = <span class="keyword">new</span> Dictionary&lt;<span class="built_in">int</span>, <span class="built_in">int</span>&gt;();</span><br><span class="line">    <span class="comment">//判断当前end指针是否超过整个数组的长度</span></span><br><span class="line">    <span class="keyword">while</span> (end &lt; fruits.Length) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> temp = fruits[end++];</span><br><span class="line">        <span class="keyword">if</span> (!pairs.ContainsKey(temp))</span><br><span class="line">        &#123;</span><br><span class="line">            pairs.Add(temp, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            pairs[temp] += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当窗口区间的数据不满足我们的要求时，左指针start开始移动</span></span><br><span class="line">        <span class="keyword">while</span> (pairs.Count &gt; <span class="number">2</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">int</span> tempend = fruits[start++];</span><br><span class="line">            <span class="keyword">if</span> (pairs[tempend] == <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                pairs.Remove(tempend);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">            &#123;</span><br><span class="line">                pairs[tempend] -= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        result = Math.Max(end-start, result);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-1611-使整数变为0的最少操作次数</title>
    <url>/2022/10/13/Leetcode-1611-%E4%BD%BF%E6%95%B4%E6%95%B0%E5%8F%98%E4%B8%BA0%E7%9A%84%E6%9C%80%E5%B0%91%E6%93%8D%E4%BD%9C%E6%AC%A1%E6%95%B0/</url>
    <content><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个整数<code>n</code>，你需要重复执行多次下述操作将其转换为<code>0</code>：</p>
<ul>
<li>翻转<code>n</code>的二进制表示中最右侧位（第<code>0</code>位）。</li>
<li>如果第<code>(i-1)</code>位为<code>1</code>且从第<code>(i-2)</code>位到第<code>0</code>位都为<code>0</code>，则翻转<code>n</code>的二进制表示中的第<code>i</code>位。</li>
</ul>
<p>返回将 n 转换为 0 的最小操作次数。</p>
<span id="more"></span>

<h4 id="示例-1："><a href="#示例-1：" class="headerlink" title="示例 1："></a>示例 1：</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">输入：n = 3</span><br><span class="line">输出：2</span><br><span class="line">解释：3 的二进制表示为 <span class="string">&quot;11&quot;</span></span><br><span class="line"><span class="string">&quot;11&quot;</span> -&gt; <span class="string">&quot;01&quot;</span> ，执行的是第 2 种操作，因为第 0 位为 1 。</span><br><span class="line"><span class="string">&quot;01&quot;</span> -&gt; <span class="string">&quot;00&quot;</span> ，执行的是第 1 种操作。</span><br></pre></td></tr></table></figure>

<h4 id="示例-2："><a href="#示例-2：" class="headerlink" title="示例 2："></a>示例 2：</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">输入：n = 6</span><br><span class="line">输出：4</span><br><span class="line">解释：6 的二进制表示为 <span class="string">&quot;110&quot;</span>.</span><br><span class="line"><span class="string">&quot;110&quot;</span> -&gt; <span class="string">&quot;010&quot;</span> ，执行的是第 2 种操作，因为第 1 位为 1 ，第 0 到 0 位为 0 。</span><br><span class="line"><span class="string">&quot;010&quot;</span> -&gt; <span class="string">&quot;011&quot;</span> ，执行的是第 1 种操作。</span><br><span class="line"><span class="string">&quot;011&quot;</span> -&gt; <span class="string">&quot;001&quot;</span> ，执行的是第 2 种操作，因为第 0 位为 1 。</span><br><span class="line"><span class="string">&quot;001&quot;</span> -&gt; <span class="string">&quot;000&quot;</span> ，执行的是第 1 种操作。</span><br></pre></td></tr></table></figure>

<ul>
<li>提示<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">0 &lt;= n &lt;= 109</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>首先我们先观察1-7移动需要的步数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">变化     原数据 (n)        需要步数 f(n)</span><br><span class="line">100       4              7</span><br><span class="line">101       5              6</span><br><span class="line">111       7              5  </span><br><span class="line">110       6              4</span><br><span class="line">010       2              3</span><br><span class="line">011       3              2</span><br><span class="line">001       1              1</span><br><span class="line">000       0              0</span><br></pre></td></tr></table></figure>

<p>此处可以观察到数为2^k需要的步数是小于<code>2^（k+1）-1</code>中步数最多的，且其步数为<code>2^（k+1）-1</code>，例如4(2^2)，步数为2^3-1&#x3D;7</p>
<p>且从该数变为0的过程中会经过小于<code>2^（k+1）-1</code>的所有数字，则可将该题转化一下，若要求n,将n转化位2^k+j的形式，则步数为f(2^k)-f(j),例如7，为2^2+3，其步数为f(4)-f(3)&#x3D;7-2&#x3D;5</p>
<p>如何发现其规则：从该数变为0的过程中会经过小于该数的所有数字，则从4变为7的过程，首尾1不动，其实就是反向的从11（二进制）变为00（二进制）的过程，因此用f(4)-f(3)即为步数</p>
<p>只需要将该数转化为的二进制数数组，然后遍历一遍数组即可得到使整数变为0的最少操作次数</p>
<p>举例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">25 -&gt; 11001 -&gt; f(16)-f(9)=f(16)-（f(8)-f(1)）=31-(15-1)=17</span><br><span class="line"></span><br><span class="line">从后向前遍历，开始（i=0）为1，即为2^0-1=1。 temp=1</span><br><span class="line">（i=3）  即为2^4-1=15       temp=15-1=14</span><br><span class="line">（i=4）  即为2^5-1=31       temp=31-14=17</span><br></pre></td></tr></table></figure>

<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">MinimumOneBitOperations</span>(<span class="params"><span class="built_in">int</span> n</span>)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//此处将n转换为二进制数数组，从后向前遍历           </span></span><br><span class="line">    <span class="built_in">char</span>[] charArray = Convert.ToString(n, <span class="number">2</span>).ToCharArray();</span><br><span class="line">    <span class="built_in">int</span> length = charArray.Length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//如果字符为&#x27;1&#x27;,就用(2^(i+1)-1)减去result</span></span><br><span class="line">        <span class="keyword">if</span> (charArray[length - i - <span class="number">1</span>] == <span class="string">&#x27;1&#x27;</span>)               </span><br><span class="line">        &#123;</span><br><span class="line">            result = ((<span class="number">2</span> &lt;&lt; (i))<span class="number">-1</span>)-result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-769-最多能完成排序的块</title>
    <url>/2022/10/13/Leetcode-769-%E6%9C%80%E5%A4%9A%E8%83%BD%E5%AE%8C%E6%88%90%E6%8E%92%E5%BA%8F%E7%9A%84%E5%9D%97/</url>
    <content><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个长度为<code>n</code>的整数数组<code>arr</code>，它表示在<code>[0, n - 1]</code>范围内的整数的排列。</p>
<p>我们将<code>arr</code>分割成若干<code>块</code>(即分区)，并对每个块单独排序。将它们连接起来后，使得连接的结果和按升序排序后的原数组相同。</p>
<p>返回数组能分成的最多块数量。</p>
<span id="more"></span>

<h4 id="示例-1："><a href="#示例-1：" class="headerlink" title="示例 1："></a>示例 1：</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">输入: arr = [4,3,2,1,0]</span><br><span class="line">输出: 1</span><br><span class="line">解释:</span><br><span class="line">将数组分成2块或者更多块，都无法得到所需的结果。</span><br><span class="line">例如，分成 [4, 3], [2, 1, 0] 的结果是 [3, 4, 0, 1, 2]，这不是有序的数组。</span><br></pre></td></tr></table></figure>

<h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2:"></a>示例 2:</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">输入: arr = [1,0,2,3,4]</span><br><span class="line">输出: 4</span><br><span class="line">解释:</span><br><span class="line">我们可以把它分成两块，例如 [1, 0], [2, 3, 4]。</span><br><span class="line">然而，分成 [1, 0], [2], [3], [4] 可以得到最多的块数。</span><br></pre></td></tr></table></figure>

<ul>
<li>提示<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">n == arr.length</span><br><span class="line">1 &lt;= n &lt;= 10</span><br><span class="line">0 &lt;= arr[i] &lt; n</span><br><span class="line">arr 中每个元素都 不同</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>依据题意，要获取分区后分别升序排序的块连接后与原数组升序结果一致，需要获取前<code>k+1</code>个数满足[0,k],即前k+1个数中最大的数为<code>k</code>的个数。<br>例如对于数组[1,2,0,3],遍历数组，最大的数初始化为arr[0]，不满足前1个数中最大的数为0，不满足，arr[1]&#x3D;&#x3D;2,不满足前2个数中最大的数为1，arr[2]&#x3D;&#x3D;0,满足前3个数中最大的数为2，result++，arr[3]&#x3D;&#x3D;3,满足前4个数中最大的数为3,result++;</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">MaxChunksToSorted</span>(<span class="params"><span class="built_in">int</span>[] arr</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">int</span> maxNum = arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; arr.Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        maxNum = Math.Max(maxNum, arr[i]);</span><br><span class="line">        <span class="keyword">if</span> (i == maxNum) </span><br><span class="line">        &#123;                    </span><br><span class="line">            result++;                    </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Linq</title>
    <url>/2022/10/12/Linq/</url>
    <content><![CDATA[<h3 id="LINQ介绍"><a href="#LINQ介绍" class="headerlink" title="LINQ介绍"></a>LINQ介绍</h3><h4 id="什么是LINQ"><a href="#什么是LINQ" class="headerlink" title="什么是LINQ"></a>什么是LINQ</h4><p>LINQ是英文Language Integrated Query的缩写，中文译为语言集成查询</p>
<p>LINQ(语言集成查询)是C#、VB.NET以及F#中的统一查询语法，用以检索来自不同数据源和格式的数据。它集成在c#、VB以及F#语言中，从而消除了编程语言和数据库之间的不匹配，并为不同类型的数据源提供了一个单一的查询接口。</p>
<span id="more"></span>

<h4 id="LINQ的优势"><a href="#LINQ的优势" class="headerlink" title="LINQ的优势"></a>LINQ的优势</h4><ul>
<li>熟悉的语言：C#，VB.NET，F#开发者无需学习额外的语法</li>
<li>写更少的代码：与更传统的方法相比，LINQ减少了需要编写的代码量</li>
<li>可读性更高：LINQ使代码更具可读性，因此其他开发人员可以轻松地理解和维护它</li>
<li>标准化方式查询多个数据源：可以使用同样的LINQ语法查询多个数据源</li>
<li>编译时查询的安全性：LINQ查询支持在编译时提供对象的类型检查</li>
<li>智能感知的支持：LINQ为泛型集合提供了智能感知</li>
<li>数据重塑：LINQ查询可以检索并返回不同类型的数据</li>
</ul>
<h3 id="LINQ标准查询操作符"><a href="#LINQ标准查询操作符" class="headerlink" title="LINQ标准查询操作符"></a>LINQ标准查询操作符</h3><h4 id="LINQ操作符之Where"><a href="#LINQ操作符之Where" class="headerlink" title="LINQ操作符之Where"></a>LINQ操作符之Where</h4><p>Where操作符(Linq扩展方法)基于给定的条件表达式过滤集合，并返回一个新的集合。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="meta">### 查询订单中价格大于2000 且为线上的订单</span></span><br><span class="line"><span class="keyword">var</span> list = order.Where(e =&gt; e.Price &gt; <span class="number">2000</span>).Where(e =&gt; e.Source == <span class="string">&quot;线上&quot;</span>).ToList();</span><br></pre></td></tr></table></figure>
<p><code>tips:</code>需要注意的是LINQ查询具有<code>延迟执行</code>的特性</p>
<ul>
<li>它是指查询操作并不是在查询运算符定义的时候执行，真正使用集合中的数据时才执行，例如遍历数据集合时调用MoveNext方法会触发查询操作</li>
<li>当返回值为IEnumerable<TSource>、IEnumerable&lt;IGrouping&lt;TKey, TSource&gt;&gt;和IOrderedEnumerable<TSource>的时候，Linq为延迟执行。实际上上述三个返回值类型都实现了IEnumerable<T>(公开枚举数)这个接口，yield return的返回值就是IEnumerable<T>，所以，当Linq查询操作符的返回值为上述三个类型时，查询为延迟查询，其他为立即执行。</li>
<li>如何让查询立即执行呢，可以使用LINQ内置所提供的转换操作的定义：ToArray(转换为数组)、ToDictionary(转换为字典)、ToList(转换为集合)</li>
<li>在使用的时候要注意这个特性，避免重复查询出现</li>
</ul>
<h4 id="LINQ操作符之OfType"><a href="#LINQ操作符之OfType" class="headerlink" title="LINQ操作符之OfType"></a>LINQ操作符之OfType</h4><p>OfType操作符用于根据指定的类型过滤IEnumerable中的元素，它返回一个包含指定类型的IEnumerable<T>的子集合。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="meta">### 从中筛选出类型为int类型的元素</span></span><br><span class="line"><span class="keyword">var</span> lists = <span class="keyword">new</span> List&lt;<span class="built_in">object</span>&gt; &#123; <span class="string">&quot;asdas&quot;</span>, <span class="string">&quot;asdadf&quot;</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">10.5</span>, <span class="number">15.45</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> result = lists.OfType&lt;<span class="built_in">string</span>&gt;().ToList();</span><br></pre></td></tr></table></figure>

<h4 id="LINQ操作符之OrderBy和OrderByDescending"><a href="#LINQ操作符之OrderBy和OrderByDescending" class="headerlink" title="LINQ操作符之OrderBy和OrderByDescending"></a>LINQ操作符之OrderBy和OrderByDescending</h4><p>在LINQ的查询语法中，OrderBy按升序或降序对集合的值进行排序。默认情况下，它按升序对集合进行排序，因为ascending关键字在这里是可选的。使用descending关键字对集合进行降序排序。</p>
<p>在LINQ的方法语法中，OrderBy则只能按升序对集合的值进行排序，而OrderByDescending则按降序排序，并且OrderByDescending只适用于方法语法中。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="meta">### 依据订单的价格升序排列</span></span><br><span class="line"><span class="keyword">var</span> result = list.OrderBy(e =&gt; e.Price).ToList();</span><br></pre></td></tr></table></figure>

<h4 id="LINQ操作符之ThenBy和ThenByDescending"><a href="#LINQ操作符之ThenBy和ThenByDescending" class="headerlink" title="LINQ操作符之ThenBy和ThenByDescending"></a>LINQ操作符之ThenBy和ThenByDescending</h4><p>OrderBy()方法根据指定的字段按升序对集合进行排序。在OrderBy之后使用ThenBy()方法对另一个字段上的集合按升序排序。LINQ首先根据OrderBy方法指定的主字段对集合进行排序，然后根据ThenBy方法指定的次字段对结果集合进行升序排序。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="meta">### 先依据的价格升序排列，再根据订单创建时间降序排列</span></span><br><span class="line"><span class="keyword">var</span> result = list.OrderBy(e=&gt;e.Price).ThenByDescending(e=&gt;e.CreatedAt).ToList();</span><br></pre></td></tr></table></figure>

<h4 id="LINQ操作符之-GroupBy"><a href="#LINQ操作符之-GroupBy" class="headerlink" title="LINQ操作符之 GroupBy"></a>LINQ操作符之 GroupBy</h4><p>分组操作符根据给定的键创建一组元素。这个组包含在一个特殊类型的集合中，该集合实现了一个IGrouping&lt;TKey,TSource&gt;接口，其中TKey是一个键值，在这个键值上形成了组，而TSource是与分组键值匹配的元素集合。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="meta">### 依据订单来源进行分组排序</span></span><br><span class="line"><span class="keyword">var</span> result = list.GroupBy(e=&gt;e.Source);</span><br><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> item <span class="keyword">in</span> result)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(item.Key);</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">var</span> <span class="keyword">value</span> <span class="keyword">in</span> item)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(JsonConvert.SerializeObject(<span class="keyword">value</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同时可以依据多字段进行分组排序</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="meta">### 依据订单及用户分组排序</span></span><br><span class="line"><span class="keyword">var</span> result = list.GroupBy(e=&gt;<span class="keyword">new</span> TypeA(e.Source,e.Customer)).ToList();</span><br></pre></td></tr></table></figure>

<h4 id="LINQ操作符之ToLookup"><a href="#LINQ操作符之ToLookup" class="headerlink" title="LINQ操作符之ToLookup"></a>LINQ操作符之ToLookup</h4><p>ToLookup操作符是一个扩展方法，它用于从源集合中提取一组键&#x2F;值对。在这里，结果集合中的每个元素都是一个通用的Lookup对象，该对象包含与该键匹配的键和子项。<br>LINQ方法语法中，ToLookup与GroupBy相同，唯一的区别是GroupBy的执行是延迟的，而ToLookup的执行是立即的。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> result = list.ToLookup(e=&gt;e.Source)</span><br></pre></td></tr></table></figure>

<h4 id="LINQ操作符之Join"><a href="#LINQ操作符之Join" class="headerlink" title="LINQ操作符之Join"></a>LINQ操作符之Join</h4><p>内部连接生成一个结果集，其中第一个集合的每个元素对于第二个集合中的每个匹配元素都出现一次。如果第一个集合中的元素在第二个集合中没有任何匹配的元素，那么它就不会出现在结果集中。<br>内连接仅用于从两个数据源返回匹配的元素，而从结果集中删除不匹配的元素，如图所示<br><img src="https://img-blog.csdnimg.cn/c7059d53e12a48e0a4751e41915267b2.png" alt="Linq内连接"></p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> result = customers.                <span class="comment">// 1.外部数据源</span></span><br><span class="line">    Join(</span><br><span class="line">    addresses,                         <span class="comment">// 2.内部数据源</span></span><br><span class="line">    c =&gt; c.AddressId,                  <span class="comment">// 3.外部键选择器</span></span><br><span class="line">    e =&gt; e.Id,                         <span class="comment">// 4.内部键选择器</span></span><br><span class="line">    (customers, addresses) =&gt; <span class="keyword">new</span>      <span class="comment">// 5.期望返回的结果集选择器</span></span><br><span class="line">    &#123;</span><br><span class="line">        name = customers.Name,</span><br><span class="line">        province = addresses.Province,</span><br><span class="line">        city = addresses.City,</span><br><span class="line">        district = addresses.District,</span><br><span class="line">        street = addresses.Street</span><br><span class="line">    &#125;</span><br><span class="line">    ).ToList();</span><br></pre></td></tr></table></figure>
<p>外部数据源中的外部键起到驱动作用，从内部中寻找匹配的数据，并按照结果集选择器中的去返回</p>
<h4 id="LINQ操作符之GroupJoin"><a href="#LINQ操作符之GroupJoin" class="headerlink" title="LINQ操作符之GroupJoin"></a>LINQ操作符之GroupJoin</h4><p>GroupJoin基本上是用来生成分组数据结构的。来自第一个数据源的每个项都与来自第二个数据源的一组相关项配对</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> customers = FakeData.Customers;</span><br><span class="line"><span class="keyword">var</span> addresses = FakeData.Addresses;</span><br><span class="line"><span class="keyword">var</span> result = addresses.                <span class="comment">// 1.外部数据源</span></span><br><span class="line">    GroupJoin(</span><br><span class="line">    customers,                         <span class="comment">// 2.内部数据源</span></span><br><span class="line">    c =&gt; c.Id,                         <span class="comment">// 3.外部键选择器</span></span><br><span class="line">    e =&gt; e.AddressId,                  <span class="comment">// 4.内部键选择器</span></span><br><span class="line">    (addresses, customers) =&gt; <span class="keyword">new</span>      <span class="comment">// 5.期望返回的结果集选择器</span></span><br><span class="line">    &#123;</span><br><span class="line">        addresses,</span><br><span class="line">        customers</span><br><span class="line">    &#125;</span><br><span class="line">    ).ToList();</span><br></pre></td></tr></table></figure>

<h4 id="LINQ操作符之Select"><a href="#LINQ操作符之Select" class="headerlink" title="LINQ操作符之Select"></a>LINQ操作符之Select</h4><p>投影是用于从数据源中选择数据的一种机制。你可以选择与数据源相同形式的数据(即原始数据处于其原始状态)。还可以通过对数据执行一些操作来创建新的数据形式。<br>LINQ中的Select操作符也允许我们指定我们想要检索的属性，你是想检索所有的属性，还是一些你需要在Select操作符中指定的属性。标准的LINQ选择操作符也允许我们执行一些计算。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> result = orders.Select(e =&gt; e.Customer).ToList();</span><br></pre></td></tr></table></figure>

<h4 id="LINQ操作符之SelectMany"><a href="#LINQ操作符之SelectMany" class="headerlink" title="LINQ操作符之SelectMany"></a>LINQ操作符之SelectMany</h4><p>LINQ的SelectMany操作符是将序列的每个元素投影到IEnumerable<T>并将结果序列合并为一个序列。这意味着SelectMany操作符组合来自一系列结果的记录，然后将其转换为一个结果。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> result = petOwners</span><br><span class="line">        .SelectMany(petOwner =&gt; petOwner.Pets, (petOwner, petName) =&gt; <span class="keyword">new</span> &#123; petOwner.Name, petName &#125;).Where(e=&gt;e.petName.Contains(<span class="string">&quot;S&quot;</span>));</span><br></pre></td></tr></table></figure>

<h4 id="LINQ操作符之All"><a href="#LINQ操作符之All" class="headerlink" title="LINQ操作符之All"></a>LINQ操作符之All</h4><p>C#中LINQ的All操作符用于检查数据源的所有元素是否满足给定的条件。如果所有元素都满足条件，则返回true，否则返回false。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="meta">### 判断数组中是否所有元素都大于20</span></span><br><span class="line"><span class="keyword">var</span> numbers = <span class="keyword">new</span>[] &#123; <span class="number">1</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">16</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">56</span>, <span class="number">80</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> areAllNumbersGreaterThan10 = numbers.All(x =&gt; x &gt; <span class="number">20</span>);</span><br></pre></td></tr></table></figure>

<h4 id="LINQ操作符之Any"><a href="#LINQ操作符之Any" class="headerlink" title="LINQ操作符之Any"></a>LINQ操作符之Any</h4><p>C#中LINQ的Any操作符用于检查数据源中是否至少有一个元素满足给定的条件。如果任何元素满足给定条件，则返回true，否则返回false。它也用于检查一个集合是否包含一些数据。这意味着它还检查集合的长度。如果它包含任何数据，则返回true，否则返回false。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="meta">### 判断数组中是否存在元素大于20</span></span><br><span class="line"><span class="keyword">var</span> numbers = <span class="keyword">new</span>[] &#123; <span class="number">1</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">16</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">56</span>, <span class="number">80</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> areAllNumbersGreaterThan10 = numbers.All(x =&gt; x &gt; <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">### 判断集合中是否存在元素</span></span><br><span class="line">numbers.Any();</span><br></pre></td></tr></table></figure>

<h4 id="LINQ操作符之Contains"><a href="#LINQ操作符之Contains" class="headerlink" title="LINQ操作符之Contains"></a>LINQ操作符之Contains</h4><p>Contains操作符检查指定的元素是否存在于集合中，并返回一个布尔值。<br>Contains扩展方法有两个重载，第一个重载方法需要传入一个在集合中检索的值，第二个重载方法需要传入一个附加的IEqualityComparer参数来进行自定义的相等性比较器。</p>
<p>Contains扩展方法只比较对象的引用，而不是对象的实际值。因此，为了比较student对象的值，需要通过实现IEqualityComparer接口创建一个类，该接口比较两个student对象的值并返回布尔值。</p>
<h4 id="LINQ操作符之Aggregate"><a href="#LINQ操作符之Aggregate" class="headerlink" title="LINQ操作符之Aggregate"></a>LINQ操作符之Aggregate</h4><p>Aggregate具有三种重载</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TSource <span class="title">Aggregate</span>&lt;<span class="title">TSource</span>&gt;(<span class="params"><span class="keyword">this</span> IEnumerable&lt;TSource&gt; source, </span></span></span><br><span class="line"><span class="params"><span class="function">                                         Func&lt;TSource, TSource, TSource&gt; func</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TAccumulate <span class="title">Aggregate</span>&lt;<span class="title">TSource</span>, <span class="title">TAccumulate</span>&gt;(<span class="params"><span class="keyword">this</span> IEnumerable&lt;TSource&gt; source, </span></span></span><br><span class="line"><span class="params"><span class="function">                                         TAccumulate seed, </span></span></span><br><span class="line"><span class="params"><span class="function">                                         Func&lt;TAccumulate, TSource, TAccumulate&gt; func</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TResult <span class="title">Aggregate</span>&lt;<span class="title">TSource</span>, <span class="title">TAccumulate</span>, <span class="title">TResult</span>&gt;(<span class="params"><span class="keyword">this</span> IEnumerable&lt;TSource&gt; source, </span></span></span><br><span class="line"><span class="params"><span class="function">                                         TAccumulate seed, </span></span></span><br><span class="line"><span class="params"><span class="function">                                         Func&lt;TAccumulate, TSource, TAccumulate&gt; func, </span></span></span><br><span class="line"><span class="params"><span class="function">                                         Func&lt;TAccumulate, TResult&gt; resultSelector</span>)</span>;</span><br></pre></td></tr></table></figure>

<h4 id="LINQ操作符之Average"><a href="#LINQ操作符之Average" class="headerlink" title="LINQ操作符之Average"></a>LINQ操作符之Average</h4><p>LINQ的Average方法用于计算应用该方法的集合中的数值的平均值。这个Average方法可以返回可为空或不可为空的十进制、浮点或双精度值。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> numbers = <span class="keyword">new</span>[] &#123; <span class="number">20</span>, <span class="number">30</span>, <span class="number">50</span>, <span class="number">60</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> avg = numbers.Average();</span><br></pre></td></tr></table></figure>

<h4 id="LINQ操作符之Count"><a href="#LINQ操作符之Count" class="headerlink" title="LINQ操作符之Count"></a>LINQ操作符之Count</h4><p>Count操作符用以返回集合中元素的数量或满足给定条件的元素的数量</p>
<h4 id="LINQ操作符之Max、Min、Sum"><a href="#LINQ操作符之Max、Min、Sum" class="headerlink" title="LINQ操作符之Max、Min、Sum"></a>LINQ操作符之Max、Min、Sum</h4><p>LINQ的Max()方法用以返回集合中最大的数字元素。<br>Min操作符与Max操作符类似，只是Min用以返回集合中最小的数字元素。<br>LINQ的Max()方法用以计算集合中数值项的和。</p>
<h4 id="LINQ操作符之元素操作符"><a href="#LINQ操作符之元素操作符" class="headerlink" title="LINQ操作符之元素操作符"></a>LINQ操作符之元素操作符</h4><table>
<thead>
<tr>
<th>操作符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>ElementAt</td>
<td>返回集合中指定索引处的元素。</td>
</tr>
<tr>
<td>ElementAtOrDefault</td>
<td>返回集合中指定索引处的元素，如果索引超出范围则返回默认值。</td>
</tr>
<tr>
<td>First</td>
<td>返回集合的第一个元素，或满足条件的第一个元素。</td>
</tr>
<tr>
<td>FirstOrDefault</td>
<td>返回集合的第一个元素，或满足条件的第一个元素。如果索引超出范围，返回默认值。</td>
</tr>
<tr>
<td>Last</td>
<td>返回集合的最后一个元素，或满足条件的最后一个元素</td>
</tr>
<tr>
<td>LastOrDefault</td>
<td>返回集合的最后一个元素，或满足条件的最后一个元素。如果不存在这样的元素，则返回默认值。</td>
</tr>
<tr>
<td>Single</td>
<td>返回集合中的唯一元素，或满足条件的唯一元素。</td>
</tr>
<tr>
<td>SingleOrDefault</td>
<td>返回集合中的唯一元素，或满足条件的唯一元素。如果不存在这样的元素或集合不包含恰好一个元素，则返回默认值。</td>
</tr>
</tbody></table>
<h4 id="LINQ操作符之集合操作符"><a href="#LINQ操作符之集合操作符" class="headerlink" title="LINQ操作符之集合操作符"></a>LINQ操作符之集合操作符</h4><table>
<thead>
<tr>
<th>操作符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>Distinct</td>
<td>去掉集合的重复项</td>
</tr>
<tr>
<td>Except</td>
<td>返回两个集合的不同，第一个集合的元素不能出现在第二个集合中</td>
</tr>
<tr>
<td>Intersect</td>
<td>返回两个集合的交集，即元素同时出现在两个集合中</td>
</tr>
<tr>
<td>Union</td>
<td>返回两个序列中的唯一元素，这意味着出现在两个序列中的任何一个中的唯一元素</td>
</tr>
</tbody></table>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="meta">### 去重</span></span><br><span class="line"><span class="keyword">var</span> numbers = <span class="keyword">new</span>[] &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> result = numbers.Distinct();</span><br><span class="line"></span><br><span class="line"><span class="meta">### 返回两个集合的差值</span></span><br><span class="line"><span class="keyword">var</span> numbers = <span class="keyword">new</span>[] &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> numbers2 = <span class="keyword">new</span>[] &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">11</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> result = numbers.Except(numbers2);</span><br><span class="line"></span><br><span class="line"><span class="meta">### 返回两个集合的交集</span></span><br><span class="line"><span class="keyword">var</span> result = numbers.Intersect(numbers2);</span><br><span class="line"></span><br><span class="line"><span class="meta">### 返回两个集合的并集</span></span><br><span class="line"><span class="keyword">var</span> result = numbers.Union(numbers2);</span><br></pre></td></tr></table></figure>
<h4 id="LINQ操作符之切分操作符"><a href="#LINQ操作符之切分操作符" class="headerlink" title="LINQ操作符之切分操作符"></a>LINQ操作符之切分操作符</h4><table>
<thead>
<tr>
<th>操作符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>Take</td>
<td>从序列的开头返回指定数量的连续元素</td>
</tr>
<tr>
<td>TakeWhile</td>
<td>只要满足指定的条件，就会返回序列的元素。</td>
</tr>
<tr>
<td>Skip</td>
<td>跳过序列中指定数量的元素，然后返回剩余的元素。</td>
</tr>
<tr>
<td>SkipWhile</td>
<td>只要满足指定的条件，就会跳过序列的元素。</td>
</tr>
</tbody></table>
<p><code>tips:</code>TakeWhile和Where的区别在于，TakeWhile是从前往后计算，如果遇到不满足Func条件，则提前退出。</p>
<h4 id="LINQ操作符之连接操作符"><a href="#LINQ操作符之连接操作符" class="headerlink" title="LINQ操作符之连接操作符"></a>LINQ操作符之连接操作符</h4><p>Concat操作符用于连接两个序列，生成一个新序列。</p>
<h4 id="LINQ操作符之等式操作符"><a href="#LINQ操作符之等式操作符" class="headerlink" title="LINQ操作符之等式操作符"></a>LINQ操作符之等式操作符</h4><p>SequenceEqual()用于判断两个序列中的内容是否一致。</p>
<h4 id="LINQ操作符之生成操作符"><a href="#LINQ操作符之生成操作符" class="headerlink" title="LINQ操作符之生成操作符"></a>LINQ操作符之生成操作符</h4><table>
<thead>
<tr>
<th>操作符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>DefaultEmpty</td>
<td>返回指定序列的元素；如果序列为空，则返回单一实例集合中的类型参数的默认值。</td>
</tr>
<tr>
<td>Empty</td>
<td>初始化集合</td>
</tr>
<tr>
<td>Range</td>
<td>生成指定范围内的整数的序列</td>
</tr>
<tr>
<td>Repeat</td>
<td>生成包含一个重复值的序列</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>C#</category>
      </categories>
      <tags>
        <tag>Linq</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-453-最小操作次数使数组元素相等</title>
    <url>/2022/10/12/Leetcode-453-%E6%9C%80%E5%B0%8F%E6%93%8D%E4%BD%9C%E6%AC%A1%E6%95%B0%E4%BD%BF%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E7%9B%B8%E7%AD%89/</url>
    <content><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个长度为 n 的整数数组，每次操作将会使 n - 1 个元素增加 1 。返回让数组所有元素相等的最小操作次数。</p>
<span id="more"></span>

<h4 id="示例-1："><a href="#示例-1：" class="headerlink" title="示例 1："></a>示例 1：</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,2,3]</span><br><span class="line">输出：3</span><br><span class="line">解释：</span><br><span class="line">只需要3次操作（注意每次操作会增加两个元素的值）：</span><br><span class="line">[1,2,3]  =&gt;  [2,3,3]  =&gt;  [3,4,3]  =&gt;  [4,4,4]</span><br></pre></td></tr></table></figure>

<h4 id="示例-2："><a href="#示例-2：" class="headerlink" title="示例 2："></a>示例 2：</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,1,1]</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure>

<ul>
<li>提示<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">n == nums.length</span><br><span class="line">1 &lt;= nums.length &lt;= 105</span><br><span class="line">-109 &lt;= nums[i] &lt;= 109</span><br><span class="line">答案保证符合 32-bit 整数</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>题目为每次操作将会让 n - 1 个元素增加 1 ，反着理解的话即为每次将 1 个元素减少 1 让数组中元素相等，这样就变为了数组中所有元素变为数组中最小元素需要的次数，先获取最小值，然后差值求和</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">MinMoves</span>(<span class="params"><span class="built_in">int</span>[] nums</span>)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> minNum = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="built_in">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//此处用于获取数组中的最小元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; nums.Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        minNum = Math.Min(minNum, nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//差值求和</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt;nums.Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        result += (nums[i]=minNum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-870.优势洗牌</title>
    <url>/2022/10/10/Leetcode-870-%E4%BC%98%E5%8A%BF%E6%B4%97%E7%89%8C/</url>
    <content><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定两个大小相等的数组 nums1 和 nums2，nums1 相对于 nums2 的优势可以用满足 nums1[i] &gt; nums2[i] 的索引 i 的数目来描述。</p>
<p>返回 nums1 的任意排列，使其相对于 nums2 的优势最大化。</p>
<span id="more"></span>

<h4 id="示例-1："><a href="#示例-1：" class="headerlink" title="示例 1："></a>示例 1：</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">输入：nums1 = [2,7,11,15], nums2 = [1,10,4,11]</span><br><span class="line">输出：[2,11,7,15]</span><br></pre></td></tr></table></figure>
<h4 id="示例-2："><a href="#示例-2：" class="headerlink" title="示例 2："></a>示例 2：</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">输入：nums1 = [12,24,8,32], nums2 = [13,25,32,11]</span><br><span class="line">输出：[24,32,8,12]</span><br></pre></td></tr></table></figure>

<ul>
<li>提示：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1 &lt;= nums1.length &lt;= 105</span><br><span class="line">nums2.length == nums1.length</span><br><span class="line">0 &lt;= nums1[i], nums2[i] &lt;= 109</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>依据题目，要想获取优势最大化，使用田忌赛马策略，首先将数组nums1进行排序，然后获取nums2排序后的下标数组<br>然后使用双指针的策略，遍历数组，将nums1[i]与nums2[下标]进行比较，若nums1[i]较大，则赋值到下标sort_Nums2_Index[start]处，并移动start，若nums1[i]较小，则赋值到下标sort_Nums2_Index[end]处，并移动end。采用田忌赛马策略，若我的最小比你的最小大，则对上你的最小，若我的最小比你的最小小，则对上你的最大。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span>[] <span class="title">AdvantageCount</span>(<span class="params"><span class="built_in">int</span>[] nums1, <span class="built_in">int</span>[] nums2</span>)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//将数组nums1进行排序</span></span><br><span class="line">    Array.Sort(nums1);</span><br><span class="line">    <span class="built_in">int</span>[] result = <span class="keyword">new</span> <span class="built_in">int</span>[nums1.Length];</span><br><span class="line">    <span class="built_in">int</span>[] sort_Nums2_Index = <span class="keyword">new</span> <span class="built_in">int</span>[nums1.Length];</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; nums1.Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        sort_Nums2_Index[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取nums2排序后的下标数组</span></span><br><span class="line">    Array.Sort(sort_Nums2_Index, (i, j) =&gt; nums2[i] - nums2[j]);</span><br><span class="line">    <span class="built_in">int</span> start = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">int</span> end = nums1.Length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; nums1.Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums1[i] &gt; nums2[sort_Nums2_Index[start]])</span><br><span class="line">        &#123;</span><br><span class="line">            result[sort_Nums2_Index[start]] = nums1[i];</span><br><span class="line">            start++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            result[sort_Nums2_Index[end]] = nums1[i];</span><br><span class="line">            end--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
</search>
