<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Linq</title>
      <link href="/2022/10/12/Linq-md/"/>
      <url>/2022/10/12/Linq-md/</url>
      
        <content type="html"><![CDATA[<h3 id="LINQ介绍"><a href="#LINQ介绍" class="headerlink" title="LINQ介绍"></a>LINQ介绍</h3><h4 id="什么是LINQ"><a href="#什么是LINQ" class="headerlink" title="什么是LINQ"></a>什么是LINQ</h4><p>LINQ是英文Language Integrated Query的缩写，中文译为语言集成查询</p><p>LINQ(语言集成查询)是C#、VB.NET以及F#中的统一查询语法，用以检索来自不同数据源和格式的数据。它集成在c#、VB以及F#语言中，从而消除了编程语言和数据库之间的不匹配，并为不同类型的数据源提供了一个单一的查询接口。</p><span id="more"></span><h4 id="LINQ的优势"><a href="#LINQ的优势" class="headerlink" title="LINQ的优势"></a>LINQ的优势</h4><ul><li>熟悉的语言：C#，VB.NET，F#开发者无需学习额外的语法</li><li>写更少的代码：与更传统的方法相比，LINQ减少了需要编写的代码量</li><li>可读性更高：LINQ使代码更具可读性，因此其他开发人员可以轻松地理解和维护它</li><li>标准化方式查询多个数据源：可以使用同样的LINQ语法查询多个数据源</li><li>编译时查询的安全性：LINQ查询支持在编译时提供对象的类型检查</li><li>智能感知的支持：LINQ为泛型集合提供了智能感知</li><li>数据重塑：LINQ查询可以检索并返回不同类型的数据</li></ul><h3 id="LINQ标准查询操作符"><a href="#LINQ标准查询操作符" class="headerlink" title="LINQ标准查询操作符"></a>LINQ标准查询操作符</h3><h4 id="LINQ操作符之Where"><a href="#LINQ操作符之Where" class="headerlink" title="LINQ操作符之Where"></a>LINQ操作符之Where</h4><p>Where操作符(Linq扩展方法)基于给定的条件表达式过滤集合，并返回一个新的集合。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">### 查询订单中价格大于2000 且为线上的订单</span></span><br><span class="line"><span class="keyword">var</span> list = order.Where(e =&gt; e.Price &gt; <span class="number">2000</span>).Where(e =&gt; e.Source == <span class="string">&quot;线上&quot;</span>).ToList();</span><br></pre></td></tr></table></figure><p><code>tips:</code>需要注意的是LINQ查询具有<code>延迟执行</code>的特性</p><ul><li>它是指查询操作并不是在查询运算符定义的时候执行，真正使用集合中的数据时才执行，例如遍历数据集合时调用MoveNext方法会触发查询操作</li><li>当返回值为IEnumerable<TSource>、IEnumerable&lt;IGrouping&lt;TKey, TSource&gt;&gt;和IOrderedEnumerable<TSource>的时候，Linq为延迟执行。实际上上述三个返回值类型都实现了IEnumerable<T>(公开枚举数)这个接口，yield return的返回值就是IEnumerable<T>，所以，当Linq查询操作符的返回值为上述三个类型时，查询为延迟查询，其他为立即执行。</li><li>如何让查询立即执行呢，可以使用LINQ内置所提供的转换操作的定义：ToArray(转换为数组)、ToDictionary(转换为字典)、ToList(转换为集合)</li><li>在使用的时候要注意这个特性，避免重复查询出现</li></ul><h4 id="LINQ操作符之OfType"><a href="#LINQ操作符之OfType" class="headerlink" title="LINQ操作符之OfType"></a>LINQ操作符之OfType</h4><p>OfType操作符用于根据指定的类型过滤IEnumerable中的元素，它返回一个包含指定类型的IEnumerable<T>的子集合。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">### 从中筛选出类型为int类型的元素</span></span><br><span class="line"><span class="keyword">var</span> lists = <span class="keyword">new</span> List&lt;<span class="built_in">object</span>&gt; &#123; <span class="string">&quot;asdas&quot;</span>, <span class="string">&quot;asdadf&quot;</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">10.5</span>, <span class="number">15.45</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> result = lists.OfType&lt;<span class="built_in">string</span>&gt;().ToList();</span><br></pre></td></tr></table></figure><h4 id="LINQ操作符之OrderBy和OrderByDescending"><a href="#LINQ操作符之OrderBy和OrderByDescending" class="headerlink" title="LINQ操作符之OrderBy和OrderByDescending"></a>LINQ操作符之OrderBy和OrderByDescending</h4><p>在LINQ的查询语法中，OrderBy按升序或降序对集合的值进行排序。默认情况下，它按升序对集合进行排序，因为ascending关键字在这里是可选的。使用descending关键字对集合进行降序排序。</p><p>在LINQ的方法语法中，OrderBy则只能按升序对集合的值进行排序，而OrderByDescending则按降序排序，并且OrderByDescending只适用于方法语法中。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">### 依据订单的价格升序排列</span></span><br><span class="line"><span class="keyword">var</span> result = list.OrderBy(e =&gt; e.Price).ToList();</span><br></pre></td></tr></table></figure><h4 id="LINQ操作符之ThenBy和ThenByDescending"><a href="#LINQ操作符之ThenBy和ThenByDescending" class="headerlink" title="LINQ操作符之ThenBy和ThenByDescending"></a>LINQ操作符之ThenBy和ThenByDescending</h4><p>OrderBy()方法根据指定的字段按升序对集合进行排序。在OrderBy之后使用ThenBy()方法对另一个字段上的集合按升序排序。LINQ首先根据OrderBy方法指定的主字段对集合进行排序，然后根据ThenBy方法指定的次字段对结果集合进行升序排序。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">### 先依据的价格升序排列，再根据订单创建时间降序排列</span></span><br><span class="line"><span class="keyword">var</span> result = list.OrderBy(e=&gt;e.Price).ThenByDescending(e=&gt;e.CreatedAt).ToList();</span><br></pre></td></tr></table></figure><h4 id="LINQ操作符之-GroupBy"><a href="#LINQ操作符之-GroupBy" class="headerlink" title="LINQ操作符之 GroupBy"></a>LINQ操作符之 GroupBy</h4><p>分组操作符根据给定的键创建一组元素。这个组包含在一个特殊类型的集合中，该集合实现了一个IGrouping&lt;TKey,TSource&gt;接口，其中TKey是一个键值，在这个键值上形成了组，而TSource是与分组键值匹配的元素集合。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">### 依据订单来源进行分组排序</span></span><br><span class="line"><span class="keyword">var</span> result = list.GroupBy(e=&gt;e.Source);</span><br><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> item <span class="keyword">in</span> result)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(item.Key);</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">var</span> <span class="keyword">value</span> <span class="keyword">in</span> item)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(JsonConvert.SerializeObject(<span class="keyword">value</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时可以依据多字段进行分组排序</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">### 依据订单及用户分组排序</span></span><br><span class="line"><span class="keyword">var</span> result = list.GroupBy(e=&gt;<span class="keyword">new</span> TypeA(e.Source,e.Customer)).ToList();</span><br></pre></td></tr></table></figure><h4 id="LINQ操作符之ToLookup"><a href="#LINQ操作符之ToLookup" class="headerlink" title="LINQ操作符之ToLookup"></a>LINQ操作符之ToLookup</h4><p>ToLookup操作符是一个扩展方法，它用于从源集合中提取一组键&#x2F;值对。在这里，结果集合中的每个元素都是一个通用的Lookup对象，该对象包含与该键匹配的键和子项。<br>LINQ方法语法中，ToLookup与GroupBy相同，唯一的区别是GroupBy的执行是延迟的，而ToLookup的执行是立即的。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result = list.ToLookup(e=&gt;e.Source)</span><br></pre></td></tr></table></figure><h4 id="LINQ操作符之Join"><a href="#LINQ操作符之Join" class="headerlink" title="LINQ操作符之Join"></a>LINQ操作符之Join</h4><p>内部连接生成一个结果集，其中第一个集合的每个元素对于第二个集合中的每个匹配元素都出现一次。如果第一个集合中的元素在第二个集合中没有任何匹配的元素，那么它就不会出现在结果集中。<br>内连接仅用于从两个数据源返回匹配的元素，而从结果集中删除不匹配的元素，如图所示<br><img src="https://img-blog.csdnimg.cn/c7059d53e12a48e0a4751e41915267b2.png" alt="Linq内连接"></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result = customers.                <span class="comment">// 1.外部数据源</span></span><br><span class="line">    Join(</span><br><span class="line">    addresses,                         <span class="comment">// 2.内部数据源</span></span><br><span class="line">    c =&gt; c.AddressId,                  <span class="comment">// 3.外部键选择器</span></span><br><span class="line">    e =&gt; e.Id,                         <span class="comment">// 4.内部键选择器</span></span><br><span class="line">    (customers, addresses) =&gt; <span class="keyword">new</span>      <span class="comment">// 5.期望返回的结果集选择器</span></span><br><span class="line">    &#123;</span><br><span class="line">        name = customers.Name,</span><br><span class="line">        province = addresses.Province,</span><br><span class="line">        city = addresses.City,</span><br><span class="line">        district = addresses.District,</span><br><span class="line">        street = addresses.Street</span><br><span class="line">    &#125;</span><br><span class="line">    ).ToList();</span><br></pre></td></tr></table></figure><p>外部数据源中的外部键起到驱动作用，从内部中寻找匹配的数据，并按照结果集选择器中的去返回</p><h4 id="LINQ操作符之GroupJoin"><a href="#LINQ操作符之GroupJoin" class="headerlink" title="LINQ操作符之GroupJoin"></a>LINQ操作符之GroupJoin</h4><p>GroupJoin基本上是用来生成分组数据结构的。来自第一个数据源的每个项都与来自第二个数据源的一组相关项配对</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> customers = FakeData.Customers;</span><br><span class="line"><span class="keyword">var</span> addresses = FakeData.Addresses;</span><br><span class="line"><span class="keyword">var</span> result = addresses.                <span class="comment">// 1.外部数据源</span></span><br><span class="line">    GroupJoin(</span><br><span class="line">    customers,                         <span class="comment">// 2.内部数据源</span></span><br><span class="line">    c =&gt; c.Id,                         <span class="comment">// 3.外部键选择器</span></span><br><span class="line">    e =&gt; e.AddressId,                  <span class="comment">// 4.内部键选择器</span></span><br><span class="line">    (addresses, customers) =&gt; <span class="keyword">new</span>      <span class="comment">// 5.期望返回的结果集选择器</span></span><br><span class="line">    &#123;</span><br><span class="line">        addresses,</span><br><span class="line">        customers</span><br><span class="line">    &#125;</span><br><span class="line">    ).ToList();</span><br></pre></td></tr></table></figure><h4 id="LINQ操作符之Select"><a href="#LINQ操作符之Select" class="headerlink" title="LINQ操作符之Select"></a>LINQ操作符之Select</h4><p>投影是用于从数据源中选择数据的一种机制。你可以选择与数据源相同形式的数据(即原始数据处于其原始状态)。还可以通过对数据执行一些操作来创建新的数据形式。<br>LINQ中的Select操作符也允许我们指定我们想要检索的属性，你是想检索所有的属性，还是一些你需要在Select操作符中指定的属性。标准的LINQ选择操作符也允许我们执行一些计算。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result = orders.Select(e =&gt; e.Customer).ToList();</span><br></pre></td></tr></table></figure><h4 id="LINQ操作符之SelectMany"><a href="#LINQ操作符之SelectMany" class="headerlink" title="LINQ操作符之SelectMany"></a>LINQ操作符之SelectMany</h4><p>LINQ的SelectMany操作符是将序列的每个元素投影到IEnumerable<T>并将结果序列合并为一个序列。这意味着SelectMany操作符组合来自一系列结果的记录，然后将其转换为一个结果。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result = petOwners</span><br><span class="line">        .SelectMany(petOwner =&gt; petOwner.Pets, (petOwner, petName) =&gt; <span class="keyword">new</span> &#123; petOwner.Name, petName &#125;).Where(e=&gt;e.petName.Contains(<span class="string">&quot;S&quot;</span>));</span><br></pre></td></tr></table></figure><h4 id="LINQ操作符之All"><a href="#LINQ操作符之All" class="headerlink" title="LINQ操作符之All"></a>LINQ操作符之All</h4><p>C#中LINQ的All操作符用于检查数据源的所有元素是否满足给定的条件。如果所有元素都满足条件，则返回true，否则返回false。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">### 判断数组中是否所有元素都大于20</span></span><br><span class="line"><span class="keyword">var</span> numbers = <span class="keyword">new</span>[] &#123; <span class="number">1</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">16</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">56</span>, <span class="number">80</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> areAllNumbersGreaterThan10 = numbers.All(x =&gt; x &gt; <span class="number">20</span>);</span><br></pre></td></tr></table></figure><h4 id="LINQ操作符之Any"><a href="#LINQ操作符之Any" class="headerlink" title="LINQ操作符之Any"></a>LINQ操作符之Any</h4><p>C#中LINQ的Any操作符用于检查数据源中是否至少有一个元素满足给定的条件。如果任何元素满足给定条件，则返回true，否则返回false。它也用于检查一个集合是否包含一些数据。这意味着它还检查集合的长度。如果它包含任何数据，则返回true，否则返回false。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">### 判断数组中是否存在元素大于20</span></span><br><span class="line"><span class="keyword">var</span> numbers = <span class="keyword">new</span>[] &#123; <span class="number">1</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">16</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">56</span>, <span class="number">80</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> areAllNumbersGreaterThan10 = numbers.All(x =&gt; x &gt; <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">### 判断集合中是否存在元素</span></span><br><span class="line">numbers.Any();</span><br></pre></td></tr></table></figure><h4 id="LINQ操作符之Contains"><a href="#LINQ操作符之Contains" class="headerlink" title="LINQ操作符之Contains"></a>LINQ操作符之Contains</h4><p>Contains操作符检查指定的元素是否存在于集合中，并返回一个布尔值。<br>Contains扩展方法有两个重载，第一个重载方法需要传入一个在集合中检索的值，第二个重载方法需要传入一个附加的IEqualityComparer参数来进行自定义的相等性比较器。</p><p>Contains扩展方法只比较对象的引用，而不是对象的实际值。因此，为了比较student对象的值，需要通过实现IEqualityComparer接口创建一个类，该接口比较两个student对象的值并返回布尔值。</p><h4 id="LINQ操作符之Aggregate"><a href="#LINQ操作符之Aggregate" class="headerlink" title="LINQ操作符之Aggregate"></a>LINQ操作符之Aggregate</h4><p>Aggregate具有三种重载</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TSource <span class="title">Aggregate</span>&lt;<span class="title">TSource</span>&gt;(<span class="params"><span class="keyword">this</span> IEnumerable&lt;TSource&gt; source, </span></span></span><br><span class="line"><span class="params"><span class="function">                                         Func&lt;TSource, TSource, TSource&gt; func</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TAccumulate <span class="title">Aggregate</span>&lt;<span class="title">TSource</span>, <span class="title">TAccumulate</span>&gt;(<span class="params"><span class="keyword">this</span> IEnumerable&lt;TSource&gt; source, </span></span></span><br><span class="line"><span class="params"><span class="function">                                         TAccumulate seed, </span></span></span><br><span class="line"><span class="params"><span class="function">                                         Func&lt;TAccumulate, TSource, TAccumulate&gt; func</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TResult <span class="title">Aggregate</span>&lt;<span class="title">TSource</span>, <span class="title">TAccumulate</span>, <span class="title">TResult</span>&gt;(<span class="params"><span class="keyword">this</span> IEnumerable&lt;TSource&gt; source, </span></span></span><br><span class="line"><span class="params"><span class="function">                                         TAccumulate seed, </span></span></span><br><span class="line"><span class="params"><span class="function">                                         Func&lt;TAccumulate, TSource, TAccumulate&gt; func, </span></span></span><br><span class="line"><span class="params"><span class="function">                                         Func&lt;TAccumulate, TResult&gt; resultSelector</span>)</span>;</span><br></pre></td></tr></table></figure><h4 id="LINQ操作符之Average"><a href="#LINQ操作符之Average" class="headerlink" title="LINQ操作符之Average"></a>LINQ操作符之Average</h4><p>LINQ的Average方法用于计算应用该方法的集合中的数值的平均值。这个Average方法可以返回可为空或不可为空的十进制、浮点或双精度值。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> numbers = <span class="keyword">new</span>[] &#123; <span class="number">20</span>, <span class="number">30</span>, <span class="number">50</span>, <span class="number">60</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> avg = numbers.Average();</span><br></pre></td></tr></table></figure><h4 id="LINQ操作符之Count"><a href="#LINQ操作符之Count" class="headerlink" title="LINQ操作符之Count"></a>LINQ操作符之Count</h4><p>Count操作符用以返回集合中元素的数量或满足给定条件的元素的数量</p><h4 id="LINQ操作符之Max、Min、Sum"><a href="#LINQ操作符之Max、Min、Sum" class="headerlink" title="LINQ操作符之Max、Min、Sum"></a>LINQ操作符之Max、Min、Sum</h4><p>LINQ的Max()方法用以返回集合中最大的数字元素。<br>Min操作符与Max操作符类似，只是Min用以返回集合中最小的数字元素。<br>LINQ的Max()方法用以计算集合中数值项的和。</p><h4 id="LINQ操作符之元素操作符"><a href="#LINQ操作符之元素操作符" class="headerlink" title="LINQ操作符之元素操作符"></a>LINQ操作符之元素操作符</h4><table><thead><tr><th>操作符</th><th>描述</th></tr></thead><tbody><tr><td>ElementAt</td><td>返回集合中指定索引处的元素。</td></tr><tr><td>ElementAtOrDefault</td><td>返回集合中指定索引处的元素，如果索引超出范围则返回默认值。</td></tr><tr><td>First</td><td>返回集合的第一个元素，或满足条件的第一个元素。</td></tr><tr><td>FirstOrDefault</td><td>返回集合的第一个元素，或满足条件的第一个元素。如果索引超出范围，返回默认值。</td></tr><tr><td>Last</td><td>返回集合的最后一个元素，或满足条件的最后一个元素</td></tr><tr><td>LastOrDefault</td><td>返回集合的最后一个元素，或满足条件的最后一个元素。如果不存在这样的元素，则返回默认值。</td></tr><tr><td>Single</td><td>返回集合中的唯一元素，或满足条件的唯一元素。</td></tr><tr><td>SingleOrDefault</td><td>返回集合中的唯一元素，或满足条件的唯一元素。如果不存在这样的元素或集合不包含恰好一个元素，则返回默认值。</td></tr></tbody></table><h4 id="LINQ操作符之集合操作符"><a href="#LINQ操作符之集合操作符" class="headerlink" title="LINQ操作符之集合操作符"></a>LINQ操作符之集合操作符</h4><table><thead><tr><th>操作符</th><th>描述</th></tr></thead><tbody><tr><td>Distinct</td><td>去掉集合的重复项</td></tr><tr><td>Except</td><td>返回两个集合的不同，第一个集合的元素不能出现在第二个集合中</td></tr><tr><td>Intersect</td><td>返回两个集合的交集，即元素同时出现在两个集合中</td></tr><tr><td>Union</td><td>返回两个序列中的唯一元素，这意味着出现在两个序列中的任何一个中的唯一元素</td></tr></tbody></table><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">### 去重</span></span><br><span class="line"><span class="keyword">var</span> numbers = <span class="keyword">new</span>[] &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> result = numbers.Distinct();</span><br><span class="line"></span><br><span class="line"><span class="meta">### 返回两个集合的差值</span></span><br><span class="line"><span class="keyword">var</span> numbers = <span class="keyword">new</span>[] &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> numbers2 = <span class="keyword">new</span>[] &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">11</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> result = numbers.Except(numbers2);</span><br><span class="line"></span><br><span class="line"><span class="meta">### 返回两个集合的交集</span></span><br><span class="line"><span class="keyword">var</span> result = numbers.Intersect(numbers2);</span><br><span class="line"></span><br><span class="line"><span class="meta">### 返回两个集合的并集</span></span><br><span class="line"><span class="keyword">var</span> result = numbers.Union(numbers2);</span><br></pre></td></tr></table></figure><h4 id="LINQ操作符之切分操作符"><a href="#LINQ操作符之切分操作符" class="headerlink" title="LINQ操作符之切分操作符"></a>LINQ操作符之切分操作符</h4><table><thead><tr><th>操作符</th><th>描述</th></tr></thead><tbody><tr><td>Take</td><td>从序列的开头返回指定数量的连续元素</td></tr><tr><td>TakeWhile</td><td>只要满足指定的条件，就会返回序列的元素。</td></tr><tr><td>Skip</td><td>跳过序列中指定数量的元素，然后返回剩余的元素。</td></tr><tr><td>SkipWhile</td><td>只要满足指定的条件，就会跳过序列的元素。</td></tr></tbody></table><p><code>tips:</code>TakeWhile和Where的区别在于，TakeWhile是从前往后计算，如果遇到不满足Func条件，则提前退出。</p><h4 id="LINQ操作符之连接操作符"><a href="#LINQ操作符之连接操作符" class="headerlink" title="LINQ操作符之连接操作符"></a>LINQ操作符之连接操作符</h4><p>Concat操作符用于连接两个序列，生成一个新序列。</p><h4 id="LINQ操作符之等式操作符"><a href="#LINQ操作符之等式操作符" class="headerlink" title="LINQ操作符之等式操作符"></a>LINQ操作符之等式操作符</h4><p>SequenceEqual()用于判断两个序列中的内容是否一致。</p><h4 id="LINQ操作符之生成操作符"><a href="#LINQ操作符之生成操作符" class="headerlink" title="LINQ操作符之生成操作符"></a>LINQ操作符之生成操作符</h4><table><thead><tr><th>操作符</th><th>描述</th></tr></thead><tbody><tr><td>DefaultEmpty</td><td>返回指定序列的元素；如果序列为空，则返回单一实例集合中的类型参数的默认值。</td></tr><tr><td>Empty</td><td>初始化集合</td></tr><tr><td>Range</td><td>生成指定范围内的整数的序列</td></tr><tr><td>Repeat</td><td>生成包含一个重复值的序列</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> C# </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linq </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode-453-最小操作次数使数组元素相等</title>
      <link href="/2022/10/12/Leetcode-453-%E6%9C%80%E5%B0%8F%E6%93%8D%E4%BD%9C%E6%AC%A1%E6%95%B0%E4%BD%BF%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E7%9B%B8%E7%AD%89-md/"/>
      <url>/2022/10/12/Leetcode-453-%E6%9C%80%E5%B0%8F%E6%93%8D%E4%BD%9C%E6%AC%A1%E6%95%B0%E4%BD%BF%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E7%9B%B8%E7%AD%89-md/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><ul><li>给你一个长度为 n 的整数数组，每次操作将会使 n - 1 个元素增加 1 。返回让数组所有元素相等的最小操作次数。</li></ul><span id="more"></span><h3 id="示例-1："><a href="#示例-1：" class="headerlink" title="示例 1："></a>示例 1：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,2,3]</span><br><span class="line">输出：3</span><br><span class="line">解释：</span><br><span class="line">只需要3次操作（注意每次操作会增加两个元素的值）：</span><br><span class="line">[1,2,3]  =&gt;  [2,3,3]  =&gt;  [3,4,3]  =&gt;  [4,4,4]</span><br></pre></td></tr></table></figure><h3 id="示例-2："><a href="#示例-2：" class="headerlink" title="示例 2："></a>示例 2：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,1,1]</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure><ul><li>提示<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">n == nums.length</span><br><span class="line">1 &lt;= nums.length &lt;= 105</span><br><span class="line">-109 &lt;= nums[i] &lt;= 109</span><br><span class="line">答案保证符合 32-bit 整数</span><br></pre></td></tr></table></figure></li></ul><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>题目为每次操作将会让 n - 1 个元素增加 1 ，反着理解的话即为每次将 1 个元素减少 1 让数组中元素相等，这样就变为了数组中所有元素变为数组中最小元素需要的次数，先获取最小值，然后差值求和</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">MinMoves</span>(<span class="params"><span class="built_in">int</span>[] nums</span>)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> minNum = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="built_in">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//此处用于获取数组中的最小元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; nums.Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        minNum = Math.Min(minNum, nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//差值求和</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt;nums.Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        result += (nums[i]=minNum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode-870.优势洗牌</title>
      <link href="/2022/10/10/Leetcode-870-%E4%BC%98%E5%8A%BF%E6%B4%97%E7%89%8C/"/>
      <url>/2022/10/10/Leetcode-870-%E4%BC%98%E5%8A%BF%E6%B4%97%E7%89%8C/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><ul><li>给定两个大小相等的数组 nums1 和 nums2，nums1 相对于 nums2 的优势可以用满足 nums1[i] &gt; nums2[i] 的索引 i 的数目来描述。<br>返回 nums1 的任意排列，使其相对于 nums2 的优势最大化。</li></ul><span id="more"></span><h4 id="示例-1："><a href="#示例-1：" class="headerlink" title="示例 1："></a>示例 1：</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [2,7,11,15], nums2 = [1,10,4,11]</span><br><span class="line">输出：[2,11,7,15]</span><br></pre></td></tr></table></figure><h4 id="示例-2："><a href="#示例-2：" class="headerlink" title="示例 2："></a>示例 2：</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [12,24,8,32], nums2 = [13,25,32,11]</span><br><span class="line">输出：[24,32,8,12]</span><br></pre></td></tr></table></figure><ul><li>提示：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 &lt;= nums1.length &lt;= 105</span><br><span class="line">nums2.length == nums1.length</span><br><span class="line">0 &lt;= nums1[i], nums2[i] &lt;= 109</span><br></pre></td></tr></table></figure></li></ul><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>依据题目，要想获取优势最大化，使用田忌赛马策略，首先将数组nums1进行排序，然后获取nums2排序后的下标数组<br>然后使用双指针的策略，遍历数组，将nums1[i]与nums2[下标]进行比较，若nums1[i]较大，则赋值到下标sort_Nums2_Index[start]处，并移动start，若nums1[i]较小，则赋值到下标sort_Nums2_Index[end]处，并移动end。采用田忌赛马策略，若我的最小比你的最小大，则对上你的最小，若我的最小比你的最小小，则对上你的最大。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span>[] <span class="title">AdvantageCount</span>(<span class="params"><span class="built_in">int</span>[] nums1, <span class="built_in">int</span>[] nums2</span>)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//将数组nums1进行排序</span></span><br><span class="line">    Array.Sort(nums1);</span><br><span class="line">    <span class="built_in">int</span>[] result = <span class="keyword">new</span> <span class="built_in">int</span>[nums1.Length];</span><br><span class="line">    <span class="built_in">int</span>[] sort_Nums2_Index = <span class="keyword">new</span> <span class="built_in">int</span>[nums1.Length];</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; nums1.Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        sort_Nums2_Index[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取nums2排序后的下标数组</span></span><br><span class="line">    Array.Sort(sort_Nums2_Index, (i, j) =&gt; nums2[i] - nums2[j]);</span><br><span class="line">    <span class="built_in">int</span> start = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">int</span> end = nums1.Length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; nums1.Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums1[i] &gt; nums2[sort_Nums2_Index[start]])</span><br><span class="line">        &#123;</span><br><span class="line">            result[sort_Nums2_Index[start]] = nums1[i];</span><br><span class="line">            start++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            result[sort_Nums2_Index[end]] = nums1[i];</span><br><span class="line">            end--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
