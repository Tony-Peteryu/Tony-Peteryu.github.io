---
title: Leetcode-1611-使整数变为0的最少操作次数
date: 2022-10-13 19:59:20
tags: Leetcode
categories: 算法
---

### 题目
给你一个整数`n`，你需要重复执行多次下述操作将其转换为`0`：
- 翻转`n`的二进制表示中最右侧位（第`0`位）。
- 如果第`(i-1)`位为`1`且从第`(i-2)`位到第`0`位都为`0`，则翻转`n`的二进制表示中的第`i`位。

返回将 n 转换为 0 的最小操作次数。

<!--more-->

### 示例 1：
~~~bash
输入：n = 3
输出：2
解释：3 的二进制表示为 "11"
"11" -> "01" ，执行的是第 2 种操作，因为第 0 位为 1 。
"01" -> "00" ，执行的是第 1 种操作。
~~~

### 示例 2：
~~~bash
输入：n = 6
输出：4
解释：6 的二进制表示为 "110".
"110" -> "010" ，执行的是第 2 种操作，因为第 1 位为 1 ，第 0 到 0 位为 0 。
"010" -> "011" ，执行的是第 1 种操作。
"011" -> "001" ，执行的是第 2 种操作，因为第 0 位为 1 。
"001" -> "000" ，执行的是第 1 种操作。
~~~

- 提示
~~~bash
0 <= n <= 109
~~~

### 解题思路
首先我们先观察1-7移动需要的步数
~~~
变化     原数据 (n)        需要步数 f(n)
100       4              7
101       5              6
111       7              5  
110       6              4
010       2              3
011       3              2
001       1              1
000       0              0
~~~

此处可以观察到数为2^k需要的步数是小于`2^（k+1）-1`中步数最多的，且其步数为`2^（k+1）-1`，例如4(2^2)，步数为2^3-1=7

且从该数变为0的过程中会经过小于`2^（k+1）-1`的所有数字，则可将该题转化一下，若要求n,将n转化位2^k+j的形式，则步数为f(2^k)-f(j),例如7，为2^2+3，其步数为f(4)-f(3)=7-2=5

如何发现其规则：从该数变为0的过程中会经过小于该数的所有数字，则从4变为7的过程，首尾1不动，其实就是反向的从11（二进制）变为00（二进制）的过程，因此用f(4)-f(3)即为步数

只需要将该数转化为的二进制数数组，然后遍历一遍数组即可得到使整数变为0的最少操作次数

举例：
~~~bash
25 -> 11001 -> f(16)-f(9)=f(16)-（f(8)-f(1)）=31-(15-1)=17

从后向前遍历，开始（i=0）为1，即为2^0-1=1。 temp=1
（i=3）  即为2^4-1=15       temp=15-1=14
（i=4）  即为2^5-1=31       temp=31-14=17
~~~

### 代码
~~~C#
public int MinimumOneBitOperations(int n) 
{
    int result = 0;
    //此处将n转换为二进制数数组，从后向前遍历           
    char[] charArray = Convert.ToString(n, 2).ToCharArray();
    int length = charArray.Length;
    for (int i = 0; i < length; i++)
    {
        //如果字符为'1',就用(2^(i+1)-1)减去result
        if (charArray[length - i - 1] == '1')               
        {
            result = ((2 << (i))-1)-result;
        }
    }
    return result;
}
~~~