---
title: Leetcode-769-最多能完成排序的块
date: 2022-10-13 13:57:53
tags: Leetcode
categories: 算法
---

### 题目

给定一个长度为`n`的整数数组`arr`，它表示在`[0, n - 1]`范围内的整数的排列。

我们将`arr`分割成若干`块`(即分区)，并对每个块单独排序。将它们连接起来后，使得连接的结果和按升序排序后的原数组相同。

返回数组能分成的最多块数量。

<!--more-->

### 示例 1：
~~~bash
输入: arr = [4,3,2,1,0]
输出: 1
解释:
将数组分成2块或者更多块，都无法得到所需的结果。
例如，分成 [4, 3], [2, 1, 0] 的结果是 [3, 4, 0, 1, 2]，这不是有序的数组。
~~~

### 示例 2:
~~~bash
输入: arr = [1,0,2,3,4]
输出: 4
解释:
我们可以把它分成两块，例如 [1, 0], [2, 3, 4]。
然而，分成 [1, 0], [2], [3], [4] 可以得到最多的块数。
~~~

- 提示
~~~bash
n == arr.length
1 <= n <= 10
0 <= arr[i] < n
arr 中每个元素都 不同
~~~

### 解题思路
依据题意，要获取分区后分别升序排序的块连接后与原数组升序结果一致，需要获取前`k+1`个数满足[0,k],即前k+1个数中最大的数为`k`的个数。
例如对于数组[1,2,0,3],遍历数组，最大的数初始化为arr[0]，不满足前1个数中最大的数为0，不满足，arr[1]==2,不满足前2个数中最大的数为1，arr[2]==0,满足前3个数中最大的数为2，result++，arr[3]==3,满足前4个数中最大的数为3,result++;

### 代码
~~~C#
public int MaxChunksToSorted(int[] arr)
{
    int result = 0;
    int maxNum = arr[0];
    for (int i = 0; i < arr.Length; i++)
    {
        maxNum = Math.Max(maxNum, arr[i]);
        if (i == maxNum) 
        {                    
            result++;                    
        }
    }
    return result;
}
~~~