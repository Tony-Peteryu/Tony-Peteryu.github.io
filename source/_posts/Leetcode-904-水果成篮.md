---
title: Leetcode-904-水果成篮
date: 2022-10-17 10:45:10
tags: Leetcode
categories: 算法
---

### 题目
你正在探访一家农场，农场从左到右种植了一排果树。这些树用一个整数数组`fruits`表示，其中`fruits[i]`是第`i`棵树上的水果 种类 。

<!--more-->

你想要尽可能多地收集水果。然而，农场的主人设定了一些严格的规矩，你必须按照要求采摘水果：
- 你只有`两个`篮子，并且每个篮子只能装 单一类型 的水果。每个篮子能够装的水果总量没有限制。
- 你可以选择任意一棵树开始采摘，你必须从 每棵 树（包括开始采摘的树）上 恰好摘一个水果 。采摘的水果应当符合篮子中的水果类型。每采摘一次，你将会向右移动到下一棵树，并继续采摘。
- 一旦你走到某棵树前，但水果不符合篮子的水果类型，那么就必须停止采摘。

给你一个整数数组`fruits`，返回你可以收集的水果的`最大`数目。

### 示例 1：
~~~bash
输入：fruits = [1,2,1]
输出：3
解释：可以采摘全部 3 棵树。
~~~

### 示例 2：
~~~bash
输入：fruits = [0,1,2,2]
输出：3
解释：可以采摘 [1,2,2] 这三棵树。
如果从第一棵树开始采摘，则只能采摘 [0,1] 这两棵树。
~~~

### 示例 3：
~~~bash
输入：fruits = [1,2,3,2,2]
输出：4
解释：可以采摘 [2,3,2,2] 这四棵树。
如果从第一棵树开始采摘，则只能采摘 [1,2] 这两棵树。
~~~

### 示例 4：
~~~bash
输入：fruits = [3,3,3,1,2,1,1,2,3,3,4]
输出：5
解释：可以采摘 [1,2,1,1,2] 这五棵树。
~~~

- 提示
~~~bash
1 <= fruits.length <= 105
0 <= fruits[i] < fruits.length
~~~

### 解题思路
此题采用滑动窗口算法的思路
- 定义start,end=0，为我们初始的滑动窗口
- 开始循环遍历整个数组元素，判断当前end指针是否超过整个数组的长度，是退出循环，否则执行第3步
- 然后end指针开始向右移动一个长度，并更新窗口内的区间数据
- 当窗口区间的数据不满足我们的要求时，右指针end就保持不变，左指针start开始移动，直到移动到一个满足要求的区间时，start不再移动位置
- 执行第2步

`例`
~~~bash
fruits = [3,3,3,1,2,1,1,2,3,3,4]
end 移动 窗口元素为[3]，满足仅有两个元素的要求
end 移动 窗口元素为[3,3]，满足仅有两个元素的要求
end 移动 窗口元素为[3,3,3]，满足仅有两个元素的要求
end 移动 窗口元素为[3,3,3,1]，满足仅有两个元素的要求     result=4
end 移动 窗口元素为[3,3,3,1,2]，不满足仅有两个元素的要求 
start 移动 窗口元素为[3,3,1,2]，不满足仅有两个元素的要求
start 移动 窗口元素为[3,1,2]，不满足仅有两个元素的要求
start 移动 窗口元素为[1,2]，满足仅有两个元素的要求
end 移动 窗口元素为[1,2,1]，满足仅有两个元素的要求
end 移动 窗口元素为[1,2,1,1]，满足仅有两个元素的要求
end 移动 窗口元素为[1,2,1,1,2]，满足仅有两个元素的要求      result=5
end 移动 窗口元素为[1,2,1,1,2,3]，不满足仅有两个元素的要求
start 移动 窗口元素为[2,1,1,2,3]，不满足仅有两个元素的要求
start 移动 窗口元素为[1,1,2,3]，不满足仅有两个元素的要求
start 移动 窗口元素为[1,2,3]，不满足仅有两个元素的要求
start 移动 窗口元素为[2,3]，满足仅有两个元素的要求
end 移动 窗口元素为[2,3,3]，满足仅有两个元素的要求
end 移动 窗口元素为[2,3,3,4]，不满足仅有两个元素的要求
start 移动 窗口元素为[3,3,4]，满足仅有两个元素的要求
结束
~~~

### 代码
~~~C#
public int TotalFruit(int[] fruits) 
{
    int start = 0;
    int end = 0;
    int result = 0;
    Dictionary<int, int> pairs = new Dictionary<int, int>();
    //判断当前end指针是否超过整个数组的长度
    while (end < fruits.Length) 
    {
        int temp = fruits[end++];
        if (!pairs.ContainsKey(temp))
        {
            pairs.Add(temp, 1);
        }
        else 
        {
            pairs[temp] += 1;
        }
        //当窗口区间的数据不满足我们的要求时，左指针start开始移动
        while (pairs.Count > 2) 
        {
            int tempend = fruits[start++];
            if (pairs[tempend] == 1)
            {
                pairs.Remove(tempend);
            }
            else 
            {
                pairs[tempend] -= 1;
            }
        }

        result = Math.Max(end-start, result);
    }
    return result;
}

~~~